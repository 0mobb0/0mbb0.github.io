<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>微架构安全论文学习集 | All about secret</title><meta name="author" content="mobb"><meta name="copyright" content="mobb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spectre AttacksAbstract幽灵攻击包括诱导受害者推测执行在正确程序执行期间不会发生的操作，并通过侧通道将受害者的机密信息泄露给对手。本文描述了结合了侧信道攻击、故障攻击和面向返回的编程方法的实际攻击，这些方法可以从受害者的进程中读取任意内存。更广泛地说，本文表明推测执行实现违反了支持许多软件安全机制的安全假设，包括操作系统进程分离、容器化、即时(JIT)编译以及缓存定时和侧信道">
<meta property="og:type" content="article">
<meta property="og:title" content="微架构安全论文学习集">
<meta property="og:url" content="http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/index.html">
<meta property="og:site_name" content="All about secret">
<meta property="og:description" content="Spectre AttacksAbstract幽灵攻击包括诱导受害者推测执行在正确程序执行期间不会发生的操作，并通过侧通道将受害者的机密信息泄露给对手。本文描述了结合了侧信道攻击、故障攻击和面向返回的编程方法的实际攻击，这些方法可以从受害者的进程中读取任意内存。更广泛地说，本文表明推测执行实现违反了支持许多软件安全机制的安全假设，包括操作系统进程分离、容器化、即时(JIT)编译以及缓存定时和侧信道">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg">
<meta property="article:published_time" content="2024-10-09T02:47:23.000Z">
<meta property="article:modified_time" content="2024-11-14T08:24:28.730Z">
<meta property="article:author" content="mobb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微架构安全论文学习集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-14 16:24:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">All about secret</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">微架构安全论文学习集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-09T02:47:23.000Z" title="发表于 2024-10-09 10:47:23">2024-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:24:28.730Z" title="更新于 2024-11-14 16:24:28">2024-11-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微架构安全论文学习集"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spectre-Attacks"><a href="#Spectre-Attacks" class="headerlink" title="Spectre Attacks"></a>Spectre Attacks</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>幽灵攻击包括诱导受害者推测执行在正确程序执行期间不会发生的操作，并通过侧通道将受害者的机密信息泄露给对手。本文描述了结合了侧信道攻击、故障攻击和面向返回的编程方法的实际攻击，这些方法可以从受害者的进程中读取任意内存。更广泛地说，本文表明推测执行实现违反了支持许多软件安全机制的安全假设，包括操作系统进程分离、容器化、即时(JIT)编译以及缓存定时和侧信道攻击的对策。这些攻击对实际系统构成严重威胁，因为数十亿设备中使用的英特尔、AMD和ARM的微处理器中存在易受攻击的推测执行能力。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>其中一个进步是推测执行，它被广泛用于提高性能，并涉及让CPU猜测可能的未来执行方向，并提前执行这些路径上的指令。更具体地说，考虑一个例子，其中程序的控制流依赖于位于外部物理内存中的未缓存值。由于此内存比CPU慢得多，因此通常需要数百个时钟周期才能知道该值。CPU没有通过空闲来浪费这些周期，而是尝试猜测控制流的方向，保存其寄存器状态的检查点，并继续在猜测的路径上推测地执行程序。当值最终从内存到达时，CPU检查其初始猜测的正确性。如果猜测错误，CPU将通过将寄存器状态恢复到存储的检查点来丢弃错误的推测执行，从而导致性能与空闲相当。</p>
<p><strong>transient instructions</strong>：能够被推测性地执行</p>
<ul>
<li><p>Attack using native code</p>
</li>
<li><p>Attack using JavaScript and eBPF</p>
</li>
</ul>
<p>得知受害者二进制文件和操作系统的共享库，寻找可用于从受害者地址空间泄露信息的指令序列，泄露内存，<strong>确切的说攻击者首先在进程地址空间中定位或引入一系列指令，这些指令在执行时充当隐蔽通道发射器，泄漏受害者的内存或寄存器内容。然后，攻击者欺骗CPU推测并错误地执行此指令序列，从而通过隐蔽通道泄露受害者的信息。</strong></p>
<ul>
<li>Variant 1：利用条件分支</li>
<li>Variant 2：利用间接分支，不依赖于受害者代码中的漏洞，与ROP不同，攻击者训练分支目标缓冲区(BTB)来错误地预测从间接分支指令到小工具地址的分支，从而导致小工具的推测执行。为了误用BTB，攻击者在受害者的地址空间中找到小工具的虚拟地址，然后对该地址执行间接分支。这种训练是从攻击者的地址空间完成的。在攻击者的地址空间中，小工具地址中驻留的内容并不重要。<strong>只要攻击者训练的虚拟地址和受害者程序的虚拟地址匹配就行</strong></li>
</ul>
<p>Hardware：</p>
<ul>
<li>Intel：Ivy Bridge、Haswell、Broadwell、Skylake和Kaby Lake处理器</li>
<li>验证了该攻击对AMD Ryzen cpu的适用性。最后，我们还成功地对流行手机中几种基于arm的三星和高通处理器进行了Spectre攻击。</li>
</ul>
<h2 id="了解的背景知识"><a href="#了解的背景知识" class="headerlink" title="了解的背景知识"></a>了解的背景知识</h2><h3 id="ROP（Reorder-Buffer）"><a href="#ROP（Reorder-Buffer）" class="headerlink" title="ROP（Reorder Buffer）"></a>ROP（Reorder Buffer）</h3><ul>
<li>通过寄存器重命名（Register Renaming）和跟踪指令的依赖关系来实现乱序执行。图中的左侧展示了指令的程序顺序（Program Order），而右侧则展示了这些指令在 Reorder Buffer 中的表示方式。</li>
<li><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/v2-4bec91a0d68451a9c7d184492a1ec887_r.jpg" alt="img"></li>
<li>右侧显示了 Reorder Buffer 中的条目。每个条目都包含指令的相关信息：目标寄存器、指令内容、依赖关系以及准备情况。具体的解释如下：<ul>
<li><strong>Entry</strong>：ROB 的条目编号，用于区分不同的指令。每个条目表示一个指令的执行和提交信息。</li>
<li><strong>RegRename</strong>：寄存器重命名。由于乱序执行中不同指令可能同时读写相同的寄存器，这里使用物理寄存器（P1, P2, P3…）来代替逻辑寄存器（R1, R2, R3）。物理寄存器用于暂存结果，直到指令 retire 后再将结果写入逻辑寄存器。</li>
<li><strong>Instruction</strong>：指令内容，展示了每条指令的操作细节。</li>
<li><strong>Deps</strong>：依赖关系。指示该指令依赖哪些其他指令的结果。比如，<code>P3 = R1 + R2</code> 依赖于前两条指令的执行结果（依赖 1 和 2）。</li>
<li>**Ready?**：指示该指令是否可以执行或提交（Y 表示准备好了，N 表示尚未准备好）。通常，指令的准备情况取决于它的依赖指令是否已经完成。</li>
</ul>
</li>
<li><strong>数据冒险</strong><ul>
<li>**写后读 (RAW, Read After Write)**：如果指令 B 需要读取寄存器 R1 的值，而前面的指令 A 尚未完成对 R1 的写操作，那么指令 B 就会读取到错误的旧数据。</li>
<li>**写后写 (WAW, Write After Write)**：如果指令 A 和指令 B 都要写入寄存器 R1，而指令 B 先完成，它的结果可能会被指令 A 的结果覆盖，导致最终 R1 中保存了错误的值。</li>
<li>**读后写 (WAR, Write After Read)**：如果指令 A 读取了寄存器 R1，而指令 B 写入了寄存器 R1，但指令 A 比指令 B 先执行，那么指令 A 可能会读取到错误的值。</li>
</ul>
</li>
</ul>
<h3 id="CDB（Common-Data-Bus）"><a href="#CDB（Common-Data-Bus）" class="headerlink" title="CDB（Common Data Bus）"></a>CDB（Common Data Bus）</h3><p><strong>Common Data Bus (CDB)</strong> 是现代处理器中用来解决指令依赖和并行执行的一项关键机制。CDB 的作用是将执行单元的结果广播给所有正在等待该结果的其他指令。具体来说：</p>
<ol>
<li><strong>结果的广播机制</strong>：当指令在执行单元中计算出结果后，这个结果通过 CDB 广播给处理器中所有等待该结果的指令。CDB 相当于一个全局的数据传输通道，允许不同的单元（如预留站、ROB）获取结果。</li>
<li><strong>提升指令并行性</strong>：假设某条指令已经计算出结果并通过 CDB 广播，那么其他指令无需等待这条指令 retire 后再继续执行，它们可以在获取结果后立即开始执行，进一步提高执行效率。例如：<ul>
<li>指令 A 计算结果并广播到 CDB。</li>
<li>指令 B 依赖于 A 的结果，一旦通过 CDB 获取到 A 的结果，指令 B 就能立即开始执行，而不用等 A 的结果写入寄存器。</li>
</ul>
</li>
<li><strong>避免数据冲突</strong>：通过 CDB，指令的结果可以快速传递给后续指令，从而避免因为结果存储在寄存器中导致的寄存器冲突问题。</li>
</ol>
<h4 id="CDB-和-ROB-的协同工作"><a href="#CDB-和-ROB-的协同工作" class="headerlink" title="CDB 和 ROB 的协同工作"></a>CDB 和 ROB 的协同工作</h4><p>CDB 和 ROB 的结合能够有效处理指令的乱序执行和依赖关系：</p>
<ul>
<li>当指令执行完毕后，结果先存储在 ROB 的对应条目中，并通过 CDB 将结果广播。</li>
<li>其他依赖该结果的指令通过 CDB 立即获取结果，开始执行。</li>
<li>只有当指令 retire 时，结果才会从 ROB 正式提交到寄存器或内存中。</li>
</ul>
<h3 id="乱序执行、分支预测、投机执行"><a href="#乱序执行、分支预测、投机执行" class="headerlink" title="乱序执行、分支预测、投机执行"></a>乱序执行、分支预测、投机执行</h3><ol>
<li><strong>乱序执行 (Out-of-Order Execution)</strong></li>
</ol>
<ul>
<li><p><strong>目的</strong>：最大化指令的利用率，减少处理器空闲时间。</p>
</li>
<li><p><strong>工作原理</strong>：处理器不再按照程序指令的原始顺序（程序顺序）来执行指令，而是根据数据依赖关系和可用的执行资源来动态调整执行顺序。只要数据依赖得到满足，指令可以先于其他指令执行。</p>
<p><strong>举例</strong>：如果指令 A 需要等待内存访问，而指令 B 只需要处理器中的寄存器数据，那么处理器可以先执行 B，而不是等待 A 完成。这就提高了处理器的执行效率。</p>
</li>
<li><p><strong>重点</strong>：乱序执行必须配合 <strong>Reorder Buffer (ROB)</strong> 来保证最终结果按照程序顺序提交（Retire），以确保程序的正确性。</p>
</li>
</ul>
<ol start="2">
<li><strong>投机执行 (Speculative Execution)</strong></li>
</ol>
<ul>
<li><p><strong>目的</strong>：通过提前执行可能的指令路径，进一步提高指令级并行度，避免因控制依赖（如分支指令）带来的处理器空闲。</p>
</li>
<li><p><strong>工作原理</strong>：当处理器遇到分支指令（例如 <code>if-else</code> 语句）时，它无法立即得知分支条件的结果。这时，处理器会基于分支预测的结果，投机性地执行其中一个路径上的指令。如果预测正确，则这些提前执行的指令结果可以直接使用；如果预测错误，则丢弃投机执行的结果，并回滚到正确的分支路径上。</p>
<p><strong>举例</strong>：假设处理器预测某个条件为真，提前执行了 <code>if</code> 块中的指令。如果之后发现条件为假，它会丢弃执行结果并改为执行 <code>else</code> 块中的指令。</p>
</li>
<li><p><strong>重点</strong>：投机执行是在尚未确定执行路径的情况下，提前执行指令，并且依赖 <strong>分支预测</strong> 来决定哪条路径更有可能。</p>
</li>
</ul>
<ol start="3">
<li><strong>分支预测 (Branch Prediction)</strong></li>
</ol>
<ul>
<li><p><strong>目的</strong>：减少分支指令（如条件判断、循环等）对流水线的阻塞，防止处理器在遇到分支时陷入空闲状态。</p>
</li>
<li><p><strong>工作原理</strong>：当处理器遇到分支指令时，它不能立即确定程序将进入哪条路径（例如 <code>if-else</code> 语句的哪一条）。分支预测器根据历史信息或者特定的预测算法，猜测分支的走向，以便处理器可以继续执行指令，而不是等待分支的计算结果。</p>
<p><strong>举例</strong>：假设处理器遇到 <code>if (a &gt; b)</code>，而目前它还没有计算出 <code>a</code> 和 <code>b</code> 的值，那么分支预测器会根据历史数据或猜测来预测分支的走向。根据预测结果，处理器可以开始执行对应分支上的指令。</p>
</li>
<li><p><strong>重点</strong>：分支预测是为了减少 <strong>控制冒险</strong>（控制依赖）的影响，通过预测分支走向来尽可能保持流水线的执行不中断。</p>
</li>
</ul>
<p>三者的联系与区别：</p>
<ul>
<li><strong>乱序执行</strong> 主要针对数据依赖，通过调整指令执行顺序来提高执行效率，前提是确保数据依赖不被破坏。</li>
<li><strong>投机执行</strong> 是在分支预测的基础上，提前执行某些尚未确定路径上的指令，以减少分支指令对流水线的影响。</li>
<li><strong>分支预测</strong> 则是通过历史数据或算法，预测条件分支的走向，决定投机执行应该进行哪个分支的指令。</li>
</ul>
<h3 id="缓存架构与地址映射"><a href="#缓存架构与地址映射" class="headerlink" title="缓存架构与地址映射"></a>缓存架构与地址映射</h3><p>缓存通常是<strong>组相联缓存</strong>，比如8路组相联的缓存。每个缓存集合（set）包含多个缓存行（line），在8路组相联缓存中，每个集合有8个缓存行。对于内存地址，通常会经过如下几步映射到缓存：</p>
<ul>
<li><strong>块偏移（Block Offset）</strong>：确定在缓存行中的具体偏移量。</li>
<li><strong>集合索引（Set Index）</strong>：用于决定该内存地址属于哪个缓存集合。</li>
<li><strong>标记（Tag）</strong>：用于区分不同的内存块，防止冲突。</li>
</ul>
<p>每个内存地址通过集合索引映射到一个特定的缓存集合。多个内存地址可以映射到同一个缓存集合，但它们会占据集合中的不同缓存行。</p>
<p>假设我们有一个内存地址：<strong>0x1234ABCD</strong>。将其转换为二进制形式：<code>0001 0010 0011 0100 1010 1011 1100 1101</code>。</p>
<ol>
<li><strong>块偏移</strong>（低6位）：<code>1101 101</code>（即十进制的<code>0x1D</code>）</li>
<li><strong>集合索引</strong>（中间6位）：<code>1010 10</code>（即十进制的<code>0x2A</code>）</li>
<li><strong>标记</strong>（高20位）：<code>0001 0010 0011 0100 10</code>（即十进制的<code>0x12342</code>）</li>
</ol>
<p>因此，地址<code>0x1234ABCD</code>对应的缓存映射信息是：</p>
<ul>
<li><strong>标记（Tag）</strong>：<code>0x12342</code></li>
<li><strong>集合索引（Set Index）</strong>：<code>0x2A</code></li>
<li><strong>块偏移（Block Offset）</strong>：<code>0x1D</code></li>
</ul>
<p><strong>缓存访问过程</strong></p>
<ol>
<li><strong>定位集合</strong>：根据集合索引<code>0x2A</code>，我们定位到第42个集合。</li>
<li><strong>匹配标记</strong>：在集合42中，有8个缓存行。缓存会检查这8个缓存行的标记，看是否有标记为<code>0x12342</code>的缓存行。</li>
<li>一旦确定了正确的缓存行，块偏移便用于定位该行中的具体数据。例如，如果块偏移为 <code>0x1D</code>，在64字节的缓存行中，它指向缓存行内的第29个字节。</li>
<li>命中与否<ul>
<li>如果找到一个缓存行的标记与<code>0x12342</code>匹配，则为<strong>缓存命中</strong>。此时会直接读取对应缓存行中的数据，通过块偏移<code>0x1D</code>定位到具体的字节。</li>
<li>如果没有找到匹配的标记，则为<strong>缓存未命中</strong>，需要从主内存中加载数据，并将其存入集合42的某个缓存行中，同时将标记设置为<code>0x12342</code>。</li>
</ul>
</li>
</ol>
<h3 id="AES加密与传统攻击"><a href="#AES加密与传统攻击" class="headerlink" title="AES加密与传统攻击"></a>AES加密与传统攻击</h3><p>AES 的加密过程包括若干轮次的操作，每一轮次包含多个步骤，如字节替换、行移位、列混淆和轮密钥加等。AES支持128位、192位和256位密钥，最常用的是AES-128，它使用128位的密钥和128位的块数据进行加密。<strong>对称加密</strong></p>
<p><strong>核心结构：</strong></p>
<p><strong>初始密钥加</strong>：在加密一开始，将128位明文与128位密钥进行初始的异或操作，称为“初始轮”。</p>
<p><strong>轮函数</strong>：AES的加密过程由多轮操作组成：</p>
<ul>
<li><strong>字节替换（SubBytes）</strong>：通过S盒（Substitution box）对每个字节进行非线性替换。</li>
<li><strong>行移位（ShiftRows）</strong>：对状态中的字节进行行级别的循环左移。</li>
<li><strong>列混淆（MixColumns）</strong>：对状态中的每列数据进行多项式运算，提供混淆效果（注意：在AES的最后一轮不执行此步）。</li>
<li><strong>轮密钥加（AddRoundKey）</strong>：与当前轮的密钥进行异或运算。</li>
</ul>
<p><strong>最后一轮</strong>：与普通轮函数类似，但跳过列混淆步骤，最终生成密文。</p>
<p><strong>详细加密步骤：</strong></p>
<ol>
<li> 明文块、秘钥块、密文块都以4*4（16字节）的矩阵表示</li>
</ol>
<p>   <img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023111555621.png" alt="image-20241023111555621"></p>
<p>   最后一轮只进行1、2、4的运算</p>
<p>   <img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023111719260.png" alt="image-20241023111719260"></p>
<ol start="2">
<li><p>轮函数</p>
<ul>
<li><p>初试变换（初始密钥加）：明文与初始密钥进行异或</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023112209316.png" alt="image-20241023112209316"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023112238790.png" alt="image-20241023112238790"></p>
</li>
<li><p>字节代换，查S-BOX进行矩阵中数据的替换（比如3d就代表在S-BOX中第四行（第0行为第一行）的第d列（第0列为第1列）</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023112615546.png" alt="image-20241023112615546"></p>
</li>
<li><p>行位移</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023112835276.png" alt="image-20241023112835276"></p>
</li>
<li><p>列混合（与一个给定的正矩阵相乘）</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023112953770.png" alt="image-20241023112953770"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023113102588.png" alt="image-20241023113102588"></p>
</li>
</ul>
</li>
<li><p>轮密钥加（与当前轮秘钥进行异或，轮秘钥经过密钥拓展得到）</p>
<p>  <img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023113318071.png" alt="image-20241023113318071"></p>
<ul>
<li>密钥拓展（i为列的下标，从0开始）<img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023113740883.png" alt="image-20241023113740883">如果是下标是4的倍数，那么其中一个异或数据就需要经过一个T函数运算得到<img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023114024503.png" alt="image-20241023114024503">T函数<ol>
<li>字循环</li>
</ol>
<img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023114309266.png" alt="image-20241023114309266"><ol start="2">
<li>字节代换（对字循环的结果进行S-BOS代换）</li>
</ol>
<img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023234843989.png" alt="image-20241023234843989"><ol start="3">
<li>轮常量异或</li>
</ol>
<img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241023235003676.png" alt="image-20241023235003676"></li>
</ul>
</li>
</ol>
<h4 id="T表"><a href="#T表" class="headerlink" title="T表"></a>T表</h4><p>AES加密的核心包括几个基本操作，如字节替换（SubBytes）、行移位（ShiftRows）、列混合（MixColumns）和轮密钥加（AddRoundKey）。这些操作中，<strong>字节替换</strong>和<strong>列混合</strong>涉及大量位操作和数学运算，尤其是在大数据量下会显著影响加密速度。</p>
<p>T表通过预先计算并存储这些运算的结果，将这些复杂的计算转化为简单的<strong>查表操作</strong>，从而极大地提升了加密过程的执行速度。</p>
<p><strong>T表的优化目的</strong></p>
<ul>
<li><strong>减少计算复杂度</strong>：在常规的AES算法中，替换每个字节以及列混合涉及多次有限域上的乘法和加法，这在实际硬件中是昂贵的操作。通过T表预先计算这些结果，在加密过程中只需要查表，避免了动态计算。</li>
<li><strong>加速轮次操作</strong>：T表的一个条目不只是简单地对应一个S盒的替换，而是将S盒操作和列混合的结果结合在一起，因此一次查表就能完成多个步骤。相比直接逐步执行SubBytes、ShiftRows、MixColumns这些操作，T表可以大幅减少计算时间。</li>
</ul>
<p><strong>T表的作用</strong></p>
<p>T表（T-tables）是一种预计算表，用来将AES的多个步骤（如SubBytes、ShiftRows、MixColumns等）结合起来优化。T表的条目相当于将一字节的输入直接映射为经过多个变换后的输出，以减少运算量。每个T表的条目包含S盒替换后的字节，同时已经包含了一部分轮次操作的结果。</p>
<p>T表的四个预计算表通常标记为 T0,T1,T2,T3每个表含有256个条目，每个条目可以表示一个字节的转换结果。因此，通过查表，可以在一次内存访问中完成多次操作。</p>
<p><strong>在缓存攻击中T表与密钥的关系</strong></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024003626678.png" alt="image-20241024003626678"></p>
<h3 id="传统的缓存攻击（以Prime-Probe为例）"><a href="#传统的缓存攻击（以Prime-Probe为例）" class="headerlink" title="传统的缓存攻击（以Prime+Probe为例）"></a>传统的缓存攻击（以Prime+Probe为例）</h3><p>传统的缓存攻击（如Prime+Probe）利用缓存侧信道来泄露加密操作中的密钥信息。这类攻击的核心原理是利用缓存的竞争机制来推断出某些内存访问模式，从而泄露加密过程中访问的缓存行，进而获取密钥。具体步骤如下：</p>
<p><strong>步骤 1：Prime 阶段</strong></p>
<ul>
<li>在Prime阶段，攻击者首先通过访问特定的内存区域来“填满”缓存的某些缓存集合（cache set）。</li>
<li>攻击者需要提前了解缓存的分组映射机制，确保可以精确控制缓存集中的哪些缓存行将被填充。</li>
</ul>
<p><strong>步骤 2：触发加密</strong></p>
<ul>
<li>攻击者触发受害者执行AES加密操作。在加密过程中，AES会访问某些内存表（如S盒表或者T表），这些表的数据通常被存放在缓存中。</li>
<li>由于AES在加密的不同轮次中会频繁访问这些表，导致部分缓存行被替换。</li>
</ul>
<p><strong>步骤 3：Probe 阶段</strong></p>
<ul>
<li>在加密操作结束后，攻击者再次访问那些之前被填满的缓存集合（即Prime阶段使用的集合），并测量访问时间。</li>
<li>如果某些缓存行被替换，访问时间会较长（因为需要从主存重新加载）；如果没有被替换，访问时间则较短。</li>
</ul>
<p>通过这种时间差，攻击者可以推断出受害者在加密过程中是否访问了某些特定的内存位置，这些位置可以泄露加密密钥的某些位。</p>
<p><strong>步骤 4：信息推断</strong></p>
<ul>
<li>由于AES在加密过程中会访问预先计算好的查找表（例如AES的T-table），攻击者可以监控这些表的缓存行访问情况，逐步推断出加密密钥的部分信息。</li>
<li>通过大量的加密追踪，攻击者可以推断出多个轮次的密钥部分信息，最终通过推断出所有的轮次密钥，恢复完整密钥。</li>
</ul>
<p>传统的缓存攻击如Prime+Probe并不是直接攻击AES的算法本身，而是通过分析加密过程中与缓存相关的访问模式泄露密钥信息。通过将缓存行为与时间差结合起来，攻击者能够在明文已知的情况下，通过观察缓存的变化，逐步推断出密钥的高位（通常是四位或更多）。</p>
<h1 id="Prime-Scope-Attack"><a href="#Prime-Scope-Attack" class="headerlink" title="Prime+Scope Attack"></a>Prime+Scope Attack</h1><h2 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>通过几乎最优的时间分辨率强化了缓存争用通道。</li>
<li>提出了一种名为Prime+Scope的跨核心缓存争用攻击，它能够进行连续的缓存争用测量，并且只访问一个缓存行。该方法的时间分辨率大约为70个周期（25纳秒），同时保持了Prime+Probe的广泛适用性。</li>
<li>为了实现如此快速的测量，主要依赖于现代处理器的确定性替换策略以及跨缓存层次的（非）交互性。<strong>提供了一种方法，基本上可以同时准备多个缓存层级，并将其应用于具有包含和非包含缓存层次结构的英特尔处理器上</strong>。对Prime+Scope的分辨率进行了量化，并通过跨核心隐蔽通道（带宽高达3.5Mbps，无需共享内存）和对AES T表的改进攻击验证了该方法。最后利用Prime+Scope的底层原理来引导构建攻击所需的驱逐集（eviction sets）</li>
</ul>
<h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>现代处理器中，共享的缓存层次结构可以跨越安全边界，这意味着不同的程序可以共享缓存，从而导致潜在的信息泄露。攻击者可以通过特定技术，比如<strong>Prime+Probe</strong>，利用缓存争用的特点推测出受害者程序的内存访问模式。这类攻击的优势在于适用性广泛，可在虚拟机、沙盒环境甚至网络通信中使用。</p>
<p><strong>时间分辨率</strong>是缓存攻击中的一个关键指标，因为它直接影响攻击者能否准确捕捉受害者的内存访问行为。在时间精度不足的情况下，过去的研究通过减慢受害者程序或打断其执行来放大攻击效果，但这会影响性能。本研究提出相反的做法，寻求如何提高攻击的时间精度，而不干扰受害者的性能。</p>
<h3 id="两个挑战"><a href="#两个挑战" class="headerlink" title="两个挑战"></a>两个挑战</h3><p><strong>观察者效应</strong>：测量缓存状态本身可能会改变系统的状态，从而影响攻击的精度。</p>
<ul>
<li><strong>缓存污染</strong>：当攻击者试图读取缓存状态时，其<strong>读取操作本身可能引入新的缓存访问</strong>，导致原本缓存中的数据被替换（即缓存污染）。这会改变目标程序的缓存状态，影响攻击的准确性。</li>
<li><strong>时间延迟</strong>：测量操作需要一定的时间来完成，这段时间内系统状态可能会发生变化，包括缓存中的数据。因此，测量结果可能不能反映测量开始时刻的真实状态。</li>
<li><strong>竞争条件</strong>：在多核或多线程环境中，多个进程或线程同时访问同一块缓存可能导致竞争条件。攻击者的测量操作可能会与目标程序的竞争条件相互作用，进一步影响缓存状态。</li>
<li><strong>系统响应变化</strong>：现代操作系统和硬件通常会有各种优化机制，如预取（prefetching）、动态频率调整等，这些机制可能会因为攻击者的测量活动而激活，间接改变了系统的行为模式，从而影响攻击的效果。</li>
</ul>
<p><strong>时间窗口的限制</strong>：由于时间窗口的固定性，现有技术的时间分辨率受到了根本性的限制。</p>
<h3 id="Prime-Scope的突破"><a href="#Prime-Scope的突破" class="headerlink" title="Prime+Scope的突破"></a>Prime+Scope的突破</h3><ul>
<li>对于Prime+Probe，每次探测都需要访问与目标结构的关联度相同数量的缓存行。例如，在现代英特尔CPU中，核心共享缓存的关联度至少为11路。因此，<strong>即使克服了观察者效应，时间分辨率仍受到访问所有这些缓存行所需时间的结构性限制</strong></li>
<li><font color="red">缓存争用通道的时间分辨率可以比直接访问被监控地址的技术更高。</font>Prime+Scope是一种高精度的跨核心缓存争用攻击，<font color="red">其测量是可重复的（即每次测量后不需要重新设置缓存状态）</font>，并且从本质上是最优的（只需一次内存访问）。Prime+Scope可以以<strong>约25纳秒</strong>的精度异步监控事件，其性能显著优于类似技术。同时，<strong>Prime+Scope继承了Prime+Probe的广泛适用性。</strong></li>
<li><strong>Prime+Scope的突破</strong>：通过仅测量单个缓存行的访问延迟，避免了访问多个缓存行所带来的延迟问题，显著提升了时间分辨率，达到了25纳秒。这个结果表明，缓存争用攻击的时间精度可以比现有技术更高</li>
<li><strong>PrimeTime工具</strong>：为了帮助高效地准备缓存状态，论文提出了PrimeTime工具，自动化地寻找适用于不同缓存结构的高效Prime模式，从而提升了攻击效率。</li>
</ul>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>缓存的作用是减少CPU直接访问主内存的延迟，通过存储即将被访问的数据来提高性能。缓存行是缓存操作的基本单位，通常会按照内存地址映射到特定的集合中，多个地址可能映射到同一组，称为<strong>同余地址</strong>。</p>
<p>Intel处理器的三级缓存架构（L1、L2、LLC）根据距离CPU的远近提供不同的访问速度。L1和L2缓存是每个核心独立的，而LLC是所有核心共享的。文中介绍了包含性和非包含性LLC的区别：包含性LLC意味着上层缓存中的数据也必须保存在LLC中，而<strong>非包含性LLC则允许缓存行仅保存在L1或L2中，这样可以减少存储开销</strong>。</p>
<h3 id="Cache-Side-Channel-Attacks"><a href="#Cache-Side-Channel-Attacks" class="headerlink" title="Cache Side-Channel Attacks"></a>Cache Side-Channel Attacks</h3><ul>
<li><p>Flush+Reload</p>
</li>
<li><p>Evict+Reload</p>
</li>
<li><p>Flush+Flush</p>
</li>
<li><p>Prime+Probe</p>
<ul>
<li><p>对于跨核心攻击，攻击者通常会瞄准一个与受害者共享的包含性结构。包含性属性确保受害者私有缓存中的同余地址被驱逐，从而确保未来受害者再次访问这些地址时，必然会与攻击者测量的集合产生争用。在具有包含性最后一级缓存（LLC）的缓存层次结构中，这一要求很容易满足。<font color="red">而在非包含性Intel缓存中，适合的结构是<strong>一致性目录（Coherence Directory，CD）</strong>，它负责跟踪所有L2缓存中的缓存行</font>。CD与LLC一样，也是按集合组织的，采用相同的函数将内存地址映射到集合和切片中。攻击者不是填充LLC，而是填充CD，从而将目标地址从CD中驱逐，并由于其包含性，目标地址也会被从受害者的私有L1/L2缓存中驱逐。当缓存行从CD中被驱逐时，它们会被移动到LLC。</p>
<p>为了测量LLC（或CD）的争用，攻击者需要获取映射到同一集合的内存地址。在不知道物理地址位或缓存切片的情况下，这些所谓的<strong>驱逐集</strong>需要在运行时获取。</p>
<p>Prime+Probe的一个变种是<strong>Prime+Abort</strong>，这是一种利用Intel TSX技术的争用知情攻击。当某些缓存行从LLC中被驱逐时，TSX事务会中止，因此该技术适用于测量LLC的争用，无论是用于攻击还是防御。然而，Intel TSX可能不会暴露给攻击者（如在浏览器中），或者出于安全原因被禁用，或者根本不可用。</p>
</li>
</ul>
<h3 id="Cache-Manipulation-Paradigms"><a href="#Cache-Manipulation-Paradigms" class="headerlink" title="Cache Manipulation Paradigms"></a>Cache Manipulation Paradigms</h3><ul>
<li>在缓存攻击中，攻击者需要通过准备缓存状态并测量延迟来检测受害者的活动。然而，某些事件可能发生在测量之前，导致这些事件被“盲区”遗漏。为了缓解这个问题，技术通常会在准备和测量之间插入等待期，这虽然会增加攻击的检测率，但也带来了<strong>时间分辨率</strong>的限制。</li>
<li><strong>盲区的影响</strong>：不同的缓存攻击技术如Flush+Reload和Evict+Reload都会遇到盲区问题，因为刷新或驱逐缓存行需要时间。在这种情况下，事件如果发生在缓存状态未被重置之前，可能会无法被捕获。</li>
<li><strong>窗口化的权衡</strong>：虽然引入等待期可以提高检测的成功率，但同时会降低时间分辨率，因为每个周期都变得更长。这是攻击精度和速度之间的权衡。</li>
<li>尽管如此，攻击者可以通过一些技巧（如同步和交错操作）来绕过盲区，特别是当攻击目标是频繁或可预测的事件时。</li>
</ul>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024181740585.png" alt="image-20241024181740585"></p>
<h4 id="Windowless-Paradigm"><a href="#Windowless-Paradigm" class="headerlink" title="Windowless Paradigm"></a>Windowless Paradigm</h4><p><strong>盲区的来源</strong>：</p>
<ul>
<li><strong>非保持性</strong>：测量过程中，缓存状态发生变化，导致需要重复准备阶段，这会遗漏一些事件。</li>
<li><strong>非并发性</strong>：测量和事件无法同时发生，导致重叠事件无法被检测。</li>
</ul>
<p><strong>无窗口化技术</strong>：如果测量既是保持性的又是并发性的，攻击者可以连续进行测量，无需在准备和测量之间分配等待时间。这不仅消除了盲区，还提高了时间分辨率。Prime+Abort就是一个无窗口模式的例子，其他技术如Prime+Probe在特定条件下也可以实现无窗口化。</p>
<p><strong>时间分辨率的提升</strong>：无窗口技术的时间分辨率只受到测量阶段的吞吐量影响，而不受准备阶段的时长限制。因此，在监测事件时，无窗口技术能够提供更高的时间精度，使得攻击者可以更精确地捕捉目标行为。</p>
<p><strong>Prime+Scope是无窗口化的</strong></p>
<p><strong>感受：Flush+Reload之所以是非保持性的，是因为在Reload期间，<font color="red">攻击者执行Reload的时候，实际上是会改变缓存状态</font>（因为需要测量时间），如果此时受害者也在访问与攻击者Reload相同的地址，那么可能就会导致检测盲区，因为攻击者实际访问了，但是没检测出来，而Prime+Probe不会，<font color="red">在Probe阶段，只要受害者访问了某些缓存行并驱逐了攻击者的缓存行，这些变化都会在攻击者的测量中反映出来。受害者的访问不会被攻击者的探测行为“覆盖”或错过</font>，因为Probe仅仅是检测缓存行是否还在，而不会主动干扰缓存。</strong></p>
<p><strong>保持性</strong>：如果所有W条缓存行（即与攻击者访问的地址相关的缓存行）都在目标结构中，那么即使攻击者重复访问这些地址，缓存状态仍然不会变化，所有缓存行会继续存在。这意味着缓存状态在每次访问前后都是一致的，这就是所谓的“保持性”。</p>
<p><strong>并发性</strong>：并发性指的是测量可以在与事件重叠的时间内进行。无论攻击者和受害者的访问是否重叠，某个受害者的事件会导致至少一条攻击者的缓存行未命中，从而被探测到。这意味着即使事件和测量发生在同一时间，它们也不会被遗漏。</p>
<p>在<strong>Flush+Reload</strong>中，覆盖是攻击的一部分，攻击者故意清除受害者的缓存行以检测其后续行为。但是，如果攻击者和受害者的访问时间重叠，<font color="red">攻击者的Reload可能会<strong>干扰</strong>受害者的行为，这种干扰就属于观察者效应。</font></p>
</li>
</ul>
<h2 id="Prime-Scope"><a href="#Prime-Scope" class="headerlink" title="Prime+Scope"></a>Prime+Scope</h2><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><ul>
<li>攻击者可以在与受害者程序相同的物理处理机上执行无特权的代码</li>
<li>攻击者代码和受害者代码不需要运行在同一个核心上</li>
<li>攻击者无法中断或控制受害者程序</li>
<li>攻击者和受害者之间无共享内存区域</li>
</ul>
<h3 id="General-Description"><a href="#General-Description" class="headerlink" title="General Description"></a>General Description</h3><ul>
<li><p>Cs表示共享且包含性的缓存结构，在其中测量争用；</p>
</li>
<li><p>Cp表示攻击者的私有缓存（例如L1缓存）</p>
</li>
<li><p>Prime+Scope有两个额外的核心要求：</p>
<ul>
<li>能够准确预测共享且包含性目标结构中的驱逐候选（EVC）。</li>
<li>从低级缓存（Cp）提供的读取不会影响目标结构（Cs）的替换状态。</li>
<li><strong>驱逐候选</strong>：当一个新缓存行需要被安装到缓存集合中时，集合中的某一缓存行（路径）会被替换。<font color="red">在本文中，我们将被替换的行称为驱逐候选（EVC）。候选行由缓存的替换策略决定</font>，替换策略由集合级别的状态机实现。例如，LRU（最近最少使用）策略下，最久未使用的缓存行是驱逐候选。尽管现代处理器实现了更复杂的替换策略，它们通常是确定性的。因此，特定的访问模式可以将替换策略的状态塑造成一个选定的缓存行作为驱逐候选。</li>
</ul>
</li>
</ul>
<h3 id="Instantition"><a href="#Instantition" class="headerlink" title="Instantition"></a>Instantition</h3><ul>
<li><p>Prime+Scope步骤工作原理</p>
<ul>
<li>Prime阶段：<ul>
<li>攻击者使用驱逐集将目标地址从共享缓存（Cs）中驱逐出去。</li>
<li>然后，攻击者使用特定的访问模式，确保驱逐集中的某一行（称为S）成为<strong>驱逐候选（EVC）</strong>。这个S行会留在低级缓存（Cp，例如L1缓存）中。</li>
</ul>
</li>
<li>Scope阶段<ul>
<li>攻击者通过低级缓存（Cp）连续访问S，并测量其访问延迟。</li>
<li>如果受害者访问了相同缓存集合并驱逐了S，S将从共享缓存（Cs）和低级缓存中被驱逐。攻击者通过检测S的高延迟来判断受害者是否访问了该地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>Prime阶段需要满足的需求</p>
<ul>
<li><p><strong>高驱逐率</strong>（RA）：驱逐集中的访问模式需要有高于99.5%的驱逐率，以确保受害者的访问能够驱逐攻击者的缓存行。</p>
<p><strong>设置EVC</strong>（RB）：攻击者需要确保特定的缓存行（S）被设为EVC。</p>
<p><strong>保持S在低级缓存中</strong>（RC）：同时，S必须保留在低级缓存中，以便攻击者通过低级缓存进行测量。</p>
</li>
<li><p><strong>说白了就是需要构建一个具备高驱逐率；能够将选定的S作为驱逐策略候选（尽量确保能够驱逐S）；确保S在低级缓存中也存在方便监测</strong></p>
</li>
</ul>
</li>
<li><p>实际的挑战</p>
<ul>
<li><strong>Challenge-LLC</strong>：保持EVC在L1缓存中。要求R_B（设定S为EVC）和R_C（保持S在低级缓存中）是矛盾的。为了让S成为EVC，S需要比其他驱逐集中的缓存行被访问得<strong>更少</strong>，但为了保持S在低级缓存中，S又需要被<strong>频繁访问</strong>。如何在这两者之间找到平衡是一个挑战</li>
<li><strong>Challenge-CD</strong>：控制EVC。传统的驱逐策略在一致性目录（CD）上表现不佳，因此在CD上控制EVC的难度更大。</li>
</ul>
</li>
</ul>
<h2 id="Finding-Efficient-Prime-Pattern"><a href="#Finding-Efficient-Prime-Pattern" class="headerlink" title="Finding Efficient Prime Pattern"></a>Finding Efficient Prime Pattern</h2><h3 id="PrimeTime"><a href="#PrimeTime" class="headerlink" title="PrimeTime"></a>PrimeTime</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/KULeuven-COSIC/PRIME-SCOPE/tree/main/primetime">PRIME-SCOPE/primetime at main · KULeuven-COSIC/PRIME-SCOPE (github.com)</a></p>
</li>
<li><h3 id="PrimeTime-的工作原理："><a href="#PrimeTime-的工作原理：" class="headerlink" title="PrimeTime 的工作原理："></a>PrimeTime 的工作原理：</h3><ol>
<li><strong>PrimeBot：访问模式生成器</strong><ul>
<li><strong>PrimeBot</strong> 是一个用于生成 Prime 访问模式的 Python 脚本。</li>
<li>它的主要任务是根据不同的策略生成大量的缓存访问模式，并将这些模式写入到一个文件中。</li>
<li>生成模式的命令是 <code>createPrimes</code>，该操作需要两个参数：第一个参数定义创建类型（比如创建大量模式或小规模模式），第二个参数指定保存模式的文件。</li>
<li>支持两种生成方式：<code>var0</code> 和 <code>var1</code>，分别生成大规模和小规模的初始访问模式集。每种方式都有各自的函数，比如 <code>var0_Primes()</code> 和 <code>var1_Primes()</code>，用于生成相应的访问模式。</li>
</ul>
</li>
<li><strong>PrimeApp：访问模式测量器</strong><ul>
<li><strong>PrimeApp</strong> 的任务是评估这些生成的访问模式的有效性。</li>
<li>具体来说，PrimeApp 会将之前生成的访问模式（日志文件中的模式）转换为 C 代码的实现，每个模式都有其对应的函数。该 C 代码文件通常位于 <code>primeapp/prime.c</code> 中。</li>
<li>为了执行这些访问模式，C 程序会针对每一个模式进行测量，例如：检查驱逐集合的第一个元素是否可以通过访问模式被设为驱逐候选（eviction candidate）。</li>
<li>需要注意的是，由于可能生成大量模式和需要进行多次迭代，系统的默认栈大小可能不够。因此，工具建议使用命令 <code>ulimit -s unlimited</code> 来增加栈大小，防止程序崩溃。</li>
</ul>
</li>
<li><strong>PrimeBot：测量结果的评估</strong><ul>
<li>测量完成后，PrimeBot 会分析生成的日志文件，并根据模式设置驱逐候选的成功率或执行时间等指标来筛选出表现最佳的模式。</li>
<li>这些经过筛选的模式可以进一步用于新的访问模式生成（通过反复执行搜索最佳模式的迭代过程），以提升攻击的效率。</li>
</ul>
</li>
</ol>
</li>
<li><p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241018165900991.png" alt="image-20241018165900991"></p>
<p><strong>R4</strong>：表示这个访问模式会重复执行 4 次。重复的原因是为了确保缓存状态稳定，让测量更加准确。</p>
<p><strong>S2</strong>：表示访问的步幅（stride）是 2，也就是说，在缓存中的两个相邻行之间会隔开 2 个位置。步幅是控制缓存行之间访问距离的关键，太小的步幅可能无法驱逐正确的行，太大的步幅则可能影响效率。</p>
<p><strong>P01S2</strong>：表示特定的访问顺序：</p>
<ul>
<li>先访问 <code>evset[0]</code>，再访问 <code>evset[1]</code>，接着返回访问 <code>evset[0]</code>，最后访问 <code>evset[2]</code>。</li>
<li>这种访问模式是为了模拟特定的缓存替换机制，从而实现驱逐（<strong>eviction</strong>）</li>
</ul>
</li>
</ul>
<h3 id="Last-Level-Cache-LLC"><a href="#Last-Level-Cache-LLC" class="headerlink" title="Last-Level Cache(LLC)"></a>Last-Level Cache(LLC)</h3><ul>
<li><p><strong>核心思想</strong>：论文提出的Prime+Scope攻击依赖于一个称为“scope line S”的缓存行（通常是第0行），在Prime模式中频繁访问S行。通过让S行持续驻留在L1缓存中，而其他行相互逐出，最终使得S成为LLC中即将被逐出的行（EVC），但实际上S仍然保留在L1中。这种策略的创新之处在于，通过巧妙的访问顺序，S行可以避免被逐出，同时准备好进行Scope操作。</p>
</li>
<li><p><strong>Prime属性</strong>：论文中提出了评估Prime模式的两个关键指标：<font color="red">逐出率（EVr）和逐出候选率（EVCr）。</font>EVr反映了该模式在Prime+Probe攻击中的有效性，而EVCr则更为重要，它是为Prime+Scope操作准备S行的成功率。EVCr ≤ EVr的关系表明，虽然某些模式可能在逐出目标行方面表现良好，但它们可能不适合用于保持S行在L1缓存中的状态，从而降低了Prime+Scope攻击的效果。</p>
</li>
<li><p><strong>方法论</strong>：PrimeTime工具的关键在于通过<strong>多阶段筛选和变异策略</strong>，逐渐筛选出适合特定微架构的访问模式。其流程从已有的访问模式模板开始，并通过变异生成新的模式，再逐步对这些模式进行严格测试。测试过程中的不同阶段逐渐提高对EVCr和执行时长的要求，最终筛选出性能最佳的模式。</p>
</li>
<li><p><strong>处理器代间差异</strong>：PrimeTime展示了它在不同英特尔处理器代上的有效性，尽管某些代的Prime模式效率较低，如Sandy Bridge。这被归因于该代处理器的MRU替换策略，而该策略与PrimeTime策略的效果并不完全兼容。</p>
</li>
<li><p><strong>序列化</strong>：PrimeTime通过自动化工具避免了手工分析和逆向工程的复杂性，但论文也指出，手工设计模式仍然是另一种可能的途径，尽管它需要对具体的缓存替换策略有更深入的了解。</p>
</li>
<li><p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241019220612384.png" alt="image-20241019220612384"></p>
<ul>
<li>```c<br>Algorithm 1 PrimeTime<br>Output: Prime patterns with high EVCr and low cycle count<br>1: Patterns ← GenerateAccessPatterns()//在第一步中，算法调用 GenerateAccessPatterns() 函数生成一组初始的缓存访问模式。这个步骤通常基于已有的模式模板进行，生成一组候选的Prime模式2: Patterns ← Mutate(Patterns, with Repeated Access)//对初始模式进行第一次变异，即增加重复访问某些特定子模式的次数。这一步骤通过重复访问某些关键行，来增强模式的逐出能力3: Patterns ← Mutate(Patterns, with interleaved S Accesses)//第二次变异在模式中引入了对S行的交错访问。S行是Prime+Scope攻击中的目标缓存行，这一步的目的是确保S行能保持在L1缓存中，不被逐出4: Measurements ← TestEviction(Patterns, 10 000 times)//在完成变异后，算法对生成的模式进行初步测试，每个模式进行10,000次逐出尝试。这是为了评估每个模式在初步阶段的表现。5: Patterns ← Filter(Patterns, Measurements, Highest EVCr 7 000 )//测试完成后，算法按照逐出候选率（EVCr）筛选出表现最好的7000个模式。这意味着，优先保留那些在Prime+Scope攻击中成功保持S行在L1缓存中的模式。6: Patterns ← Filter(Patterns, Measurements, Fastest 5 000 )//接下来，算法根据执行周期数进一步筛选，在之前筛选出的模式中，保留执行速度最快的5000个模式。这一步确保筛选出的模式不仅效果好，而且效率高。7: Measurements ← TestEviction(Patterns, 1 000 000 times)//对前面筛选出的模式进行更大规模的测试，每个模式进行1,000,000次逐出尝试。这一步是为了更严格地评估模式在大规模攻击中的表现。8: Patterns ← Filter(Patterns, Measurements, Highest EVCr 150 )//在大规模测试后，算法再次根据逐出候选率（EVCr）进行筛选，保留表现最好的150个模式。9: Patterns ← Filter(Patterns, Measurements, Fastest 100 )//最后，算法根据执行速度进一步筛选，在前150个模式中保留执行速度最快的100个模式10: return Patterns//最终，算法返回筛选出的100个最佳Prime模式，这些模式具有最高的逐出候选率（EVCr）和最短的执行周期数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + PrimeTime这种手工设计的模式通常需要串行化，**以防止乱序执行破坏预期的效果**，这样的串行化通过指针追踪或内存屏障实现，但会使得Prime模式变得更慢。PrimeTime通过在目标架构上直接执行来避免串行化，能够直接剥啄难以预测的运行时效应，尽管手工设计的模式可能比PrimeTime找到的无序模式更有效，PrimeTime生成的模式已足够适用于Prime+Scope攻击。</span><br><span class="line">  </span><br><span class="line">  + **主要优势：PrimeTime的关键优势在于简化了模式生成过程，通过自动化和适应性测试，避免了手工模式的复杂性和性能瓶颈。**</span><br><span class="line"></span><br><span class="line">### Coherence Directory (CD)</span><br><span class="line"></span><br><span class="line">+ CD的挑战：在一致性目录上实施高效的驱逐比在普通缓存上更复杂。主要原因是CD中的行驻留在低级缓存中（如L1或L2），并且传统驱逐模式的驱逐候选精度较差，无法实现Prime+Scope所需的EVC候选固定。</span><br><span class="line">+ 替换策略的假设：由于CD中的行同时存在于L1/L2中，&lt;font color=&#x27;red&#x27;&gt;攻击者需要反复访问这些行才能“使它们变得更年轻”&lt;/font&gt;，这使得CD表现得像FIFO队列。此现象解释了传统驱逐模式在CD上不佳的表现。</span><br><span class="line">+ 改进的Prime模式：**访问当前不在CD中的同余行可以形成有效的Prime模式。**该模式能够在Prime+Scope攻击中取得接近完美的EVCr，这使得它非常适合非包容性平台。</span><br><span class="line">+ 串行化和指针追踪：为了应对FIFO行为，使用指针追踪来确保访问顺序。这在某种程度上提高了攻击的效率，使得Prime+Scope能够在非包容平台上有效执行。</span><br><span class="line"></span><br><span class="line">## Case Studies</span><br><span class="line"></span><br><span class="line">### pre</span><br><span class="line"></span><br><span class="line">**Prime+Scope绕过了传统缓存争用侧信道的观察者效应，将缓存测量简化为一次单独的内存访问。因此，它能够以非常高的时间精度监测受害者的行为，甚至可以异步地进行，而无需担心遗漏访问。**</span><br><span class="line"></span><br><span class="line">**时间差异（Differential Time）：**</span><br><span class="line">通过同时监测多个缓存集合，Prime+Scope能够以很高的精度估计两个或多个事件之间的时间间隔。图5展示了两种Prime+Scope特别擅长处理的时间泄漏类别。</span><br><span class="line"></span><br><span class="line">- 第一类是**可变时间操作（Variable-Time Operation）**，即操作的执行时间依赖于某个秘密值。图5(i)展示了一个代码模式，在这个模式中，秘密被编码在操作前后内存访问的时间差异中。几种攻击利用了这种泄漏，例如依赖秘密值的循环迭代次数或非恒定时间的算术操作（例如模数运算）。只有当攻击技术的精度足够高时，才能从这些操作的时间差异中解码出秘密。然而，通常情况下，精度不足以检测到秘密相关的时间差异，因此攻击者可能会通过让受害者的性能下降来提升成功率。</span><br><span class="line">- 第二类是**可变时间访问（Variable-Time Access）**，即内存访问的时间依赖于某个秘密值（或在某些特殊情况下，访问的顺序依赖于秘密值）。图5(ii)中展示了一个函数，数组中的元素始终被访问，但访问的时间相对于函数的开始时间依赖于一个（二进制）秘密。攻击同样需要足够的精度来检测秘密相关的时间差异。</span><br><span class="line">- ![image-20241020171819832](微架构安全论文学习集/image-20241020171819832.png)</span><br><span class="line">- &lt;font color=&#x27;red&#x27;&gt;Prime+Scope主要聚焦于可变时间访问的泄露&lt;/font&gt;</span><br><span class="line">- Prime+Scope特别适合处理基于时间差异的两类泄漏。这种高精度的时间测量大大提高了攻击的有效性，尤其是在非恒定时间操作和访问的场景下。例如，AES T表的访问模式存在这种可变时间泄漏，Prime+Scope可以更有效地利用这种泄漏来减少攻击所需的跟踪次数。</span><br><span class="line"></span><br><span class="line">**隐蔽信道和同址检测：**</span><br><span class="line"></span><br><span class="line">- Prime+Scope不仅可以用于时间泄漏的攻击，还可以用于建立高容量的隐蔽信道，这意味着它能够在不易被检测到的情况下传输大量信息。</span><br><span class="line">- 它的高精度测量也可以用于同址检测，通过构建精确的驱逐集，进一步提升了在缓存攻击中的应用。</span><br><span class="line"></span><br><span class="line">### Temporal Precision</span><br><span class="line"></span><br><span class="line">+ **实验目标**：</span><br><span class="line">  </span><br><span class="line">  + 实验的核心是比较不同技术（Prime+Scope、Prime+Probe、Flush+Reload 和 Flush+Flush）的时间分辨率，这可以看作是这些技术检测异步事件的灵敏度。</span><br><span class="line">  + 其中，**Prime+Scope** 通过缓存目录（Cache Directory, CD）的观察，展示了较高的时间分辨率。</span><br><span class="line">  </span><br><span class="line">+ **窗口化技术**（如 Flush+Reload 和窗口化的 Prime+Probe）需要测量和准备阶段的交替，这自然会引入等待时间，从而限制其时间精度。这种情况下，事件发生时，如果事件落在等待期内，测量就会丢失。</span><br><span class="line"></span><br><span class="line">+ **无窗口化技术**（如 Flush+Flush、无窗口化的 Prime+Probe 和 Prime+Scope）通过连续测量来避免等待期，因此时间分辨率更高。这类技术在事件发生的任何时候都能够捕获相关信息，而不需要等待额外的准备阶段。</span><br><span class="line"></span><br><span class="line">+ **实验方法：**</span><br><span class="line"></span><br><span class="line">  + 要检测的事件是由固定到另一个核心的进程对特定缓存行的访问。为了模拟异步事件，**该进程首先让出 CPU (`sched_yield`)，然后等待随机数量的 `nop` 操作。接着，事件以 1/2 的概率触发。**</span><br><span class="line"></span><br><span class="line">  + 我们考虑图 6iii 和图 6iv 中列出的各个实例。所有实例都从已经准备好的状态开始，对于 **Prime+Probe** 和 **Prime+Scope**，使用了表 1 中排名最高的 Prime 操作。无窗口化的实例（FF、PPc、PS）执行背靠背的测量，因此不需要重复准备阶段（用 `/` 表示）。相比之下，窗口化的实例（FR、PPwA、PPwB）包含一个测量、一个准备阶段和一个等待期，直到窗口结束。所有实例都以迭代方式运行，直到检测到事件，或者没有事件发生，且随机进程已终止。</span><br><span class="line"></span><br><span class="line">  + 该实验对于每个窗口大小和每种技术重复 1,000 轮，每轮 10,000 个事件，并记录全局准确率（真阳性和真阴性除以总数）。我们还记录了基本的最大分辨率（即能够容纳一次测量迭代的最小窗口大小），以及能提供 95% 准确率的最大分辨率。</span><br><span class="line"></span><br><span class="line">  + ![image-20241021161229747](微架构安全论文学习集/image-20241021161229747.png)</span><br><span class="line"></span><br><span class="line">    + **图(i)**：展示了在 **LLC**（Core i5-7500, Kaby Lake）上，不同技术随窗口大小变化的精度曲线。</span><br><span class="line"></span><br><span class="line">      **图(ii)**：展示了在 **缓存目录（CD）**（Xeon Platinum 8280, Cascade Lake）上，不同技术随窗口大小变化的精度曲线。</span><br><span class="line"></span><br><span class="line">    + TODO：搞清每个Measure的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Susceptibility to Noise</span><br><span class="line"></span><br><span class="line">  与 Prime+Probe 类似，Prime+Scope 对来自目标缓存集合的其他活动引起的噪声较为敏感，而不仅仅是要监控的事件。**这种限制是缓存争用泄漏机制的基本特性。**因此，自然会有人问，Prime+Scope 更精确的 Prime 模式是否会使其在噪声环境下更加脆弱。</span><br><span class="line"></span><br><span class="line">  实验操作步骤</span><br><span class="line"></span><br><span class="line">1. **线程的设置**：</span><br><span class="line">   - 两个线程分别绑定到不同的核心上运行（确保它们互不干扰）。</span><br><span class="line">   - **线程 1** 定期（每 10,000 个周期）访问一个固定的内存地址。这一访问行为作为实验的“**真值**”，即目标事件。此时，**线程 1** 的内存访问会导致某个缓存集合发生变化。</span><br><span class="line">   - **线程 2** 则**持续监控该缓存集合的变化**，试图检测到线程 1 的内存访问行为（事件）。</span><br><span class="line">2. **时间戳记录**：</span><br><span class="line">   - **线程 2** 在每次检测到缓存集合发生变化时，都会记录下时间戳。时间戳使用 CPU 的时间戳计数器获得（这是一个硬件级别的计时工具，能够在多个核心之间同步，因此不会因为线程运行在不同核心而导致计时误差）。</span><br><span class="line">   - 这些时间戳记录了线程 2 检测到线程 1 内存访问的时间点。</span><br><span class="line">3. **噪声的引入**：</span><br><span class="line">   - 为了模拟真实的多任务环境，实验通过**压力工具**（Stress Tool）在其他核心上产生**内存负载**。内存负载会对缓存产生干扰，形成“噪声”。</span><br><span class="line">   - 通过调节压力工具的强度，实验设计了三种噪声场景：没有噪声（0）、中度噪声（1）、高度噪声（5），分别对应不同的噪声级别。</span><br><span class="line">4. **检测结果分类**： 实验将线程 2 的每个时间段的检测结果分为以下三类：</span><br><span class="line">   - **Correct（正确）**：在正确的时间点只检测到一个事件，且该事件正好对应于线程 1 的内存访问。</span><br><span class="line">   - **Miss（漏报）**：在时间段内没有检测到线程 1 的内存访问（即，线程 1 发生了内存访问，但线程 2 没有检测到，属于假阴性错误）。</span><br><span class="line">   - **Multi（多报）**：在时间段内检测到了多个事件，且其中有些事件不属于线程 1 的内存访问（属于假阳性错误）。</span><br><span class="line"></span><br><span class="line">**Prime+Scope 与 Prime+Probe 的对比**</span><br><span class="line"></span><br><span class="line">实验对 Prime+Scope 和 Prime+Probe 两种技术进行了对比，尤其是它们在噪声环境下的表现差异。</span><br><span class="line"></span><br><span class="line">1. **Prime+Scope（PS）**：</span><br><span class="line">   - PS 是 Prime+Scope 技术的实现，它使用特定的 Prime 访问模式来监控缓存集合中的变化。</span><br><span class="line">   - PS 的执行分为两个阶段：首先通过 Prime 操作准备好缓存集合，然后通过 Scope 操作检测目标事件。</span><br><span class="line">2. **Prime+Probe 的两种实现**：</span><br><span class="line">   - **PP_PS**：这是继承了 Prime+Scope Prime 模式的 Prime+Probe 实现，称为“PP_PS”。它连续执行 Prime 操作并进行缓存监控。</span><br><span class="line">   - **PP_CST**：这是另外一种优化过的 Prime+Probe 实现，称为“PP_CST”。该版本针对 EVr（缓存有效性）进行了优化，而不是 EVCr（缓存集合的可访问性）。</span><br><span class="line"></span><br><span class="line">**实验结果说明**</span><br><span class="line"></span><br><span class="line">- **正确率**：在无噪声情况下，PS、PP_PS 和 PP_CST 的正确率都非常高（接近 99%）。但随着噪声增加，PS 的正确率下降较快，而 PP_PS 在中度和高度噪声条件下表现得更为稳定。</span><br><span class="line">- **漏报率**：PS 的漏报率在噪声条件下略高于 PP_PS 和 PP_CST。作者解释说，这是因为在噪声条件下，Prime 步骤未能完全准备好缓存集合，导致 EVCr 不完整。</span><br><span class="line">- **多报率**：多报率是指噪声在测量阶段引起的假阳性错误。PS、PP_PS 和 PP_CST 在多报率方面表现相似，表明测量阶段的噪声对所有技术的影响大致相同。</span><br><span class="line"></span><br><span class="line">**实验的挑战与改进**</span><br><span class="line"></span><br><span class="line">实验中的 Prime+Scope 存在的一个潜在问题是，如果 Prime 步骤因为噪声未能成功修复缓存集合（EVC），后续的 Scope 操作可能会失效。为此，实验提出了一种改进方案：当在一定时间段内没有检测到事件时，可以**重复执行 Prime 步骤**。这有助于提高 Prime+Scope 在噪声条件下的稳健性。</span><br><span class="line"></span><br><span class="line">![image-20241022152726050](微架构安全论文学习集/image-20241022152726050.png)</span><br><span class="line"></span><br><span class="line">## Cross-Core Covert Cannel</span><br><span class="line"></span><br><span class="line">+ 在 **Kaby Lake** 处理器的最后一级缓存（LLC）以及 **CascadeLake-SP** 的 CD 上实现了这一隐蔽通道。</span><br><span class="line">+ 首先，接收器对集合进行准备（Prime）。然后，发射器通过在编号为 **i=M** 的槽中访问一个相应的缓存行来发送m位符号M。同时，接收器每个 **SLOT** 周期对集合进行监控，并根据哪个槽中的 **Scope** 行 **S** 被替换来解码符号 **M**。</span><br><span class="line">+ ![image-20241022160248427](微架构安全论文学习集/image-20241022160248427.png)</span><br><span class="line">+ **Gray码的用途**：在隐蔽通道中，如果某个符号被错误地解码为相邻的符号，使用Gray码可以确保只会有一位比特错误。例如，使用普通的二进制编码，000可能被误解为011（两位比特错误）。而使用Gray码，000可能只会被误解为001（只有一位比特错误），这样可以减少解码错误的影响。</span><br><span class="line">+ 对于 **LLC 通道**，接收器使用了第5.1节中的 **Prime** 模式。我们发现如果发射器在访问之后立即刷新缓存行，能略微加速接收器的 **Prime** 阶段。</span><br><span class="line">+ 对于 **CD 通道**，**Prime** 阶段由交替的指针追踪操作组成（参见第5.2节）。为了摊销串行化带来的延迟，四个集合同时进行准备，并将访问交错进行（例如如文献[16]所示）。在完成合并的 **Prime** 之后，有四轮2^m个槽，每轮编码m位。</span><br><span class="line">+ **评估**。图9展示了通道容量与错误率随带宽的变化情况，并总结了在LLC和CD通道中获得峰值容量的参数。分别地，LLC通道的容量为3.5 Mbps，CD通道为3.1 Mbps，远高于LLC上的 **Prime+Probe** （例如，在1%的比特错误率下为500 Kbps [25]）。</span><br><span class="line">+ ![image-20241022164607108](微架构安全论文学习集/image-20241022164607108.png)</span><br><span class="line"></span><br><span class="line">**发送方和接收方如何确认缓存集合和缓存行？**</span><br><span class="line"></span><br><span class="line">虽然程序员无法直接看到缓存物理地址，但通过内存地址中的部分位，发送方和接收方仍然可以利用**相同的映射规则**来确保它们操作的是同一个缓存集合，甚至是集合中的同一个缓存行。</span><br><span class="line"></span><br><span class="line">详细步骤：</span><br><span class="line"></span><br><span class="line">1. **约定缓存集合**：</span><br><span class="line">   发送方和接收方可以根据内存地址中的**集合索引位**，确定某些内存地址会映射到同一个缓存集合中。因为集合索引位是由内存地址的中间部分决定的，只要发送方和接收方使用相同的集合索引位，它们就可以确保操作的是相同的缓存集合。</span><br><span class="line"></span><br><span class="line">   例如，如果集合索引位是内存地址的第6到第14位（假设该处理器的LLC缓存使用这些位作为集合索引），那么内存地址 `0x12345678` 和 `0x56785678` 都有相同的集合索引位值，因此它们会被映射到相同的缓存集合中。</span><br><span class="line"></span><br><span class="line">2. **区分缓存行**：</span><br><span class="line">   在同一个缓存集合中，不同的内存地址会映射到不同的缓存行，这由**标记位（Tag位）**决定。发送方和接收方可以通过操作不同的内存地址（即不同的标记位），确保它们在同一个集合中选择不同的缓存行。</span><br><span class="line"></span><br><span class="line">   例如，地址 `0x12345678` 和 `0x22345678` 可能有相同的集合索引位，但它们的高位不同（Tag位不同），因此会落入同一个集合中的不同缓存行。</span><br><span class="line"></span><br><span class="line">3. **发送方的操作**：</span><br><span class="line"></span><br><span class="line">   - 发送方根据要发送的比特值选择访问不同的地址，这些地址通过相同的集合索引位映射到同一个缓存集合中的不同缓存行。例如，比特 &quot;0&quot; 访问 `0x12345678`，比特 &quot;1&quot; 访问 `0x22345678`。</span><br><span class="line">   - 发送方通过访问这些地址（缓存行），会在缓存中引起相应的变化，比如导致其他缓存行的替换（驱逐）。</span><br><span class="line"></span><br><span class="line">4. **接收方的监控**：</span><br><span class="line"></span><br><span class="line">   - 接收方会监控同一个缓存集合中的某些缓存行，通过测量访问时间来判断是否发生了替换。如果接收方测量某个缓存行的访问时间增加（比如缓存行被替换），就可以推断出发送方访问了该集合中的某一行，进而解码出比特值。</span><br><span class="line">   - 例如，如果接收方看到 `0x12345678` 对应的缓存行被替换，则知道发送方发送了比特 &quot;0&quot;；如果 `0x22345678` 的缓存行被替换，则知道发送了比特 &quot;1&quot;。</span><br><span class="line"></span><br><span class="line"> **如何通过内存地址确定集合和行的位置？**</span><br><span class="line"></span><br><span class="line">缓存行映射是由硬件的规则（如地址中的位分配）决定的。这些规则在同一台处理器中是固定的，因此发送方和接收方都可以根据内存地址的位结构计算出相同的映射关系。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Side-Channel Attack on AES</span><br><span class="line"></span><br><span class="line">TODO：[42],[18,25,57]</span><br><span class="line"></span><br><span class="line">### 攻击场景</span><br><span class="line"></span><br><span class="line">![image-20241024012403847](微架构安全论文学习集/image-20241024012403847.png)</span><br><span class="line"></span><br><span class="line">+ 在传统的攻击场景中，由于第一轮是百分百访问T表的（后面几轮可能会有重复结果，即访问同一个缓存行），所以为了得到更精确且有效的结果，大多都是对第一轮加密进行攻击。Prime+Scope也是如此，但是AES在加密过程中，Prime+Scope可以通过时间差（文章中提到第一轮大概是200-300时钟周期），这为攻击者提供了一个基准，用来判断一个表项的访问是否发生在第一轮。如果时间差远超这个范围，可能访问发生在后面的轮次。</span><br><span class="line"></span><br><span class="line">+ 之后又与Prime+Probe来进行可变时间访问的对比。给定的PP场景是最优的无窗口的配置，Prime部分与PS相同，Probe是对集合的简单无序遍历，预测精度约为400个周期（PS为70个周期）</span><br><span class="line"></span><br><span class="line">+ 图11展示了在Intel Core i7-7700K（Kaby Lake，16路）的LLC上进行AES T表攻击的结果。它显示了完成整个第一轮攻击所需的加密次数，这次攻击恢复了128位密钥中的64位。认为一旦密钥nibble的假设收敛（即达到正确值且不再偏离），该密钥nibble就被发现。我们进行了1000次迭代，并显示了中位数及10th和90th百分位数来展示方差。注意，这些结果是在不降低受害者性能（除了间接通过监控的缓存集外）的情况下获得的。</span><br><span class="line"></span><br><span class="line">  ![image-20241024191711044](微架构安全论文学习集/image-20241024191711044.png)</span><br><span class="line"></span><br><span class="line">+ Prime+Scope使用更少的追踪次数（比传统的Prime+Probe少5-25倍）就能恢复秘密信息。尽管差分时间的Prime+Probe也能捕获部分时间信息，但速度更慢，所需追踪次数更多（多10-70倍）。当每次加密只监控一个表项时，我们发现即使使用10万次追踪，Prime+Probe仍无法恢复密钥，这可能表明时间差异太小，无法被Prime+Probe区分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 分析总结</span><br><span class="line"></span><br><span class="line"> **传统攻击与Prime+Scope的对比**：</span><br><span class="line"></span><br><span class="line">- 传统攻击通过监控AES预计算表中的缓存访问来泄露密钥的部分信息。使用Prime+Probe的传统攻击在每次加密中仅能获得约7.5%的信息。</span><br><span class="line">- 而**Prime+Scope** 则利用缓存访问的**时间差异**，结合缓存访问的内容和访问时间获取更多的信息。它通过记录加密的每轮中访问的时间戳，能够比传统的Prime+Probe技术更加高效地恢复密钥。</span><br><span class="line"></span><br><span class="line">**可变时间访问的优势**：</span><br><span class="line"></span><br><span class="line">- **Prime+Scope** 不仅能够监控缓存访问，还能捕捉加密过程中不同轮次的访问时间，从而大幅提高信息获取的精度。</span><br><span class="line">- 通过记录每次访问的精确时间差，攻击者能够更快地缩小密钥空间。这使得Prime+Scope在需要的追踪次数上比传统的Prime+Probe低得多（10-70倍）。</span><br><span class="line"></span><br><span class="line">**Prime+Probe的局限性**：</span><br><span class="line"></span><br><span class="line">- Prime+Probe虽然也可以捕捉部分时间信息，但精度远不及Prime+Scope。由于Prime+Probe的时间窗口更大，导致其无法有效地区分访问时间的小差异。</span><br><span class="line">- 即使通过优化，Prime+Probe的时间精度仍达不到Prime+Scope的水平，从而需要更多的追踪来恢复密钥。</span><br><span class="line"></span><br><span class="line">**图11的结果**：</span><br><span class="line"></span><br><span class="line">- 图11展示了不同攻击方法在AES第一轮攻击中恢复密钥所需的加密次数。Prime+Scope的表现明显优于Prime+Probe和Flush+Reload，表明它在同等条件下需要的追踪次数更少，攻击效率更高。</span><br><span class="line"></span><br><span class="line">  ![image-20241024003240952](微架构安全论文学习集/image-20241024003240952.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Finding Congruent Addresses</span><br><span class="line"></span><br><span class="line">缓存争用攻击要求攻击者找到替换集（eviction sets），也就是在目标缓存中同组的地址集合。这一实际挑战已经被广泛研究过【18, 31, 37, 60, 65】。然而，Prime+Scope背后的原理使得一种有效的同组性测试成为可能，结果是一个更快且更简单的流程，反常的是，它需要的与平台相关的参数更少。</span><br><span class="line"></span><br><span class="line">**LLC：**</span><br><span class="line"></span><br><span class="line">+ 本文提出的LLC替换集构造算法的基础如算法2所示。它不断测量目标地址（TARGET）的访问延迟，并且在每次测量之间访问一个猜测的地址。**由于TARGET是持续访问的，它总是从L1缓存中提供数据，因此不会影响其在LLC的替换状态。那些与TARGET同组的猜测地址会被安装在LLC中，每次这种情况发生时，LLC中的替换候选（EVC）会发生变化。经过足够多的同组猜测后，TARGET就会成为LLC中的替换候选。下一个同组猜测地址会从LLC中替换TARGET，并且由于包含性属性（inclusion property），它也会从私有缓存（L1和L2）中被驱逐。因此，下一次访问TARGET时速度会变慢，表示最新的猜测地址与TARGET同组。**攻击者重复这个过程，直到她得到了足够多的同组地址。</span><br><span class="line"></span><br><span class="line">  &gt; 首先，你不断测量TARGET的访问时间，每次访问TARGET后访问一个猜测地址。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 当猜测地址与TARGET同组时，猜测地址会占据TARGET在LLC中的位置，导致TARGET被驱逐。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 在下一次访问TARGET时，你会发现访问时间变慢（因为它从LLC中被替换出去了），这意味着该猜测地址与TARGET同组。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 你重复这个过程，直到找到足够多的同组地址构成完整的替换集。</span><br><span class="line"></span><br><span class="line">  ![image-20241024142458711](微架构安全论文学习集/image-20241024142458711.png)</span><br><span class="line"></span><br><span class="line">+ **该算法对于大页和小页的虚拟内存页都是相同的，但由于物理地址位的控制增加【37, 60】**，猜测地址与TARGET同组的可能性增加，大页显著加快了运行时间</span><br><span class="line"></span><br><span class="line">  TODO：[37,60]</span><br><span class="line"></span><br><span class="line">**CD：**</span><br><span class="line"></span><br><span class="line">+ 在非包含式的Intel缓存上，LLC和CD的组索引映射是相同的。因此，为一个缓存构造的替换集可以用于另一个缓存。通过争用在CD中找到同组地址是具有挑战性的，因为CD中的同组意味着L2中也同组【65】，而TARGET可能因为L2的争用而被替换。因此，和之前的工作一样【65】，我们在LLC中执行构造。</span><br><span class="line"></span><br><span class="line">  这个过程与算法2类似。然而，考虑到LLC是非包含式的，因此第4行和第7行中的内存访问不保证TARGET和猜测地址被安装在LLC中。**我们用攻击者线程和另一核心的帮助线程共同访问来代替这些操作，因为我们观察到来自两个核心的访问会将该行复制到LLC中。**</span><br><span class="line"></span><br><span class="line">+ ![image-20241024144158544](微架构安全论文学习集/image-20241024144158544.png)</span><br><span class="line"></span><br><span class="line">**分析总结：**</span><br><span class="line"></span><br><span class="line">**大页和小页的影响**：</span><br><span class="line"></span><br><span class="line">- **大页优势**：由于大页有更大的物理地址控制权，猜测地址和目标地址同组的概率更高，因此使用大页时构造替换集的速度会显著提高。</span><br><span class="line"></span><br><span class="line">**包含式和非包含式缓存**：</span><br><span class="line"></span><br><span class="line">- **包含式缓存**：在包含式缓存中，替换TARGET不仅会影响LLC，还会影响私有缓存（如L1和L2）。因此替换集的构造更直接。</span><br><span class="line">- **非包含式缓存**：在非包含式缓存上，构造替换集更加复杂，需要同时访问多个核心来确保目标地址和猜测地址都能被安装在LLC中。</span><br><span class="line"></span><br><span class="line">**性能对比**：</span><br><span class="line"></span><br><span class="line">- 本文提出的算法相比之前的工作在运行速度上有了显著提升，特别是在Skylake架构上，本文算法的构造速度可以比之前的算法快660倍，同时保持了相同的成功率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## POC执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### primescope_demo</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024000949796.png" alt="image-20241024000949796"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024170020986.png" alt="image-20241024170020986"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./app --primescope</span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024162610404.png" alt="image-20241024162610404"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024163549934.png" alt="image-20241024163549934"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024163917256.png" alt="image-20241024163917256"></p>
<p> <strong>Intel i5-4570R</strong>，该处理器有 <strong>4个核心</strong> 且没有超线程（每个核心一个线程）</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024165819655.png" alt="image-20241024165819655"></p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024171021407.png" alt="image-20241024171021407"></p>
<p>在调整测试次数以及retry次数后成功率会变高且稳定，但对于跨核仍然成功率低</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./app --evset</span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024175550584.png" alt="image-20241024175550584"></p>
<p>由于虚拟机的成功率很低，所以尝试了一下启用大页面是否能提高成功率，这个看起来似乎是可行的。启用大页面步骤如下。</p>
<ol>
<li><strong>检查系统是否支持 Huge Pages</strong></li>
</ol>
<p>首先，检查你的系统是否已经支持 Huge Pages，使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep HugePages /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>如果输出中有类似以下信息，说明你的系统支持 Huge Pages：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>分配 Huge Pages</strong></li>
</ol>
<p>要启用 Huge Pages，需要为它们分配内存。可以使用 <code>sysctl</code> 或者直接修改 <code>/proc</code> 文件系统。下面的示例将分配 1024 个 Huge Pages（每个 2MB），相当于 2GB 的内存。</p>
<p>通过 <code>sysctl</code> 来分配：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.nr_hugepages=1024</span><br></pre></td></tr></table></figure>

<p>直接修改 <code>/proc</code> 文件系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1024 | sudo tee /proc/sys/vm/nr_hugepages</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>挂载 Huge Pages 文件系统</strong></li>
</ol>
<p>为了方便访问 Huge Pages，你可以挂载一个 <code>hugetlbfs</code> 文件系统。Huge Pages 通常存储在 <code>/dev/hugepages</code> 中。</p>
<p>创建挂载点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/huge</span><br></pre></td></tr></table></figure>

<p>挂载 <code>hugetlbfs</code> 文件系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t hugetlbfs none /mnt/huge</span><br></pre></td></tr></table></figure>

<p>你可以在 <code>/etc/fstab</code> 中添加一行，以便系统启动时自动挂载（可用可不用，我没用）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none /mnt/huge hugetlbfs defaults 0 0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>启用 Huge Pages 支持程序</strong></li>
</ol>
<p>回到项目，通过配置 <code>configuration.h</code> 文件中的 <code>HUGE_PAGES_AVAILABLE</code> 参数来启用 Huge Pages：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUGE_PAGES_AVAILABLE 1</span></span><br></pre></td></tr></table></figure>

<p>这将告知程序在内存分配时使用 Huge Pages。你的代码应当使用 <code>mmap</code> 来请求大页内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_HUGETLB, fd, 0);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>验证 Huge Pages</strong></li>
</ol>
<p>分配完成后，检查 Huge Pages 是否生效：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep HugePages /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>输出会显示已经分配和使用的 Huge Pages 数量：</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024190214086.png" alt="image-20241024190214086"></p>
<p>也可以使用以下命令检查挂载的 <code>hugetlbfs</code>（可用可不用，我没用）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | grep hugetlbfs</span><br></pre></td></tr></table></figure>

<p>额外优化</p>
<ul>
<li><p><strong>内存预留</strong>：你可以在启动时为 Huge Pages 预留内存。编辑 <code>/etc/sysctl.conf</code> 文件，添加以下行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.nr_hugepages=1024</span><br></pre></td></tr></table></figure></li>
<li><p>**Transparent Huge Pages (THP)**：某些 Linux 发行版支持透明大页（THP），它们会自动处理大页的分配。你可以通过以下命令启用 THP：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> always | sudo tee /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024185154834.png" alt="image-20241024185154834"></p>
<h3 id="primetime"><a href="#primetime" class="headerlink" title="primetime"></a>primetime</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./execute_PS.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024180700262.png" alt="image-20241024180700262"></p>
<p>这个脚本将执行以下操作：</p>
<ul>
<li>创建一组 <code>prime</code> 访问模式。</li>
<li>测量这些模式的性能。</li>
<li>筛选出性能最好的模式。</li>
</ul>
<p>具体每个操作所需的参数和步骤都在 <code>execute_PS.sh</code> 的顶部有详细说明。在执行时，<strong>可能会耗费数小时来完成整个过程，特别是如果你选择的操作需要多次迭代时。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./execute_PP.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241024180841583.png" alt="image-20241024180841583"></p>
<h3 id="Covert-Channel"><a href="#Covert-Channel" class="headerlink" title="Covert_Channel"></a>Covert_Channel</h3><p>运行下面的程序获取LLC的set编号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpuid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cache_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> eax, ebx, ecx, edx;</span><br><span class="line">    <span class="keyword">int</span> cache_index = <span class="number">0</span>;  <span class="comment">// 用于访问每一层缓存的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPU Cache Information:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历不同的缓存层次</span></span><br><span class="line">    <span class="keyword">while</span> (__get_cpuid_count(<span class="number">4</span>, cache_index, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx)) &#123;</span><br><span class="line">        <span class="comment">// eax 中的低 5 位是缓存类型，0 表示没有更多缓存</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cache_type = eax &amp; <span class="number">0x1F</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache_type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No more caches\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取缓存的层次（L1/L2/L3）</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cache_level = (eax &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取缓存的相关参数</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> line_size = (ebx &amp; <span class="number">0xFFF</span>) + <span class="number">1</span>;              <span class="comment">// 缓存行大小（字节数）</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ways_of_associativity = ((ebx &gt;&gt; <span class="number">22</span>) &amp; <span class="number">0x3FF</span>) + <span class="number">1</span>; <span class="comment">// 相联度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sets = ecx + <span class="number">1</span>;                             <span class="comment">// 组数</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size = line_size * ways_of_associativity * sets; <span class="comment">// 缓存大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印每一层缓存的详细信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cache Level: L%u\n&quot;</span>, cache_level);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Cache Type: %s\n&quot;</span>, cache_type == <span class="number">1</span> ? <span class="string">&quot;Data Cache&quot;</span> : (cache_type == <span class="number">2</span> ? <span class="string">&quot;Instruction Cache&quot;</span> : <span class="string">&quot;Unified Cache&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Line Size: %u bytes\n&quot;</span>, line_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Associativity: %u-way\n&quot;</span>, ways_of_associativity);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Sets: %u\n&quot;</span>, sets);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Total Size: %u KB\n&quot;</span>, cache_size / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        cache_index++; <span class="comment">// 检查下一个缓存层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_cache_info();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行下面的命令获取频率</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep <span class="string">&quot;MHz&quot;</span></span><br></pre></td></tr></table></figure>

<p>更改完covert.h后执行即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make run</span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241114152421861.png" alt="image-20241114152421861"></p>
<h1 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime+Probe"></a>Prime+Probe</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpuid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cache_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> eax, ebx, ecx, edx;</span><br><span class="line">    <span class="keyword">if</span> (__get_cpuid(<span class="number">4</span>, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cache_type = eax &amp; <span class="number">0x1F</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache_type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No more caches\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cache_level = (eax &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ways_of_associativity = ((ebx &gt;&gt; <span class="number">22</span>) &amp; <span class="number">0x3FF</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sets = ecx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> line_size = (ebx &amp; <span class="number">0xFFF</span>) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cache level: %u\n&quot;</span>, cache_level);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ways of associativity: %u\n&quot;</span>, ways_of_associativity);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sets: %u\n&quot;</span>, sets);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Line size: %u\n&quot;</span>, line_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_cache_info();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Abstract-2"><a href="#Abstract-2" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>描述了几种基于进程间泄漏的软件侧信道攻击，<strong>这种泄漏通过CPU的内存高速缓存的状态来实现</strong>。这种泄漏揭示了内存访问模式，可用于对使用数据依赖表查找的密码原语进行密码分析。这些攻击允许无特权进程攻击在同一处理器上并行运行的其他进程，尽管使用了内存保护等分区方法，沙盒和虚拟化。我们的一些方法只需要能够触发使用未知密钥执行加密或MAC的服务，例如加密的磁盘分区或安全网络链接。此外，我们演示了一种非常强大的攻击类型，它既不需要特定的明文也不需要密文的知识，只需监视加密过程对该高速缓存的影响即可。</li>
</ul>
<p>我们详细讨论了几个这样的攻击AES，并通过实验证明其适用于真实的系统，如OpenSSL和Linux的dm-crypt加密分区（在后一种情况下，完整的密钥可以恢复后，只需800写入分区，需要65毫秒）。</p>
<h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ul>
<li><strong>问题背景：</strong> 现代计算机系统通常并行执行不同权限的程序，采用各种分区方法（如内核和用户空间分离、内存保护、文件系统权限等）来实现访问控制。然而，本文提出的观点是，虽然这些访问控制机制（如虚拟内存和权限管理）保护了数据的存储，但缓存的元数据（即缓存内容的状态和内存访问模式）并没有得到充分保护。特别是，缓存作为一个共享资源，所有进程都在竞争它，因此缓存的状态受到每个进程的影响。</li>
<li><strong>攻击机制：</strong> 攻击者可以通过观察和测量缓存的状态，推测出其他进程的内存访问模式。这些攻击方法可以分为两类：<ol>
<li><strong>影响缓存状态并测量加密运行时间的方法：</strong> 这些攻击通过操作缓存来影响加密过程的执行时间，从而推测出加密密钥的信息。</li>
<li><strong>在加密过程中或之后探测缓存状态的方法：</strong> 这些方法更加有效且抗噪声能力更强，尤其是在现代CPU的执行机制中，测量加密过程中的缓存状态变化是更为直接和可靠的攻击方式。</li>
</ol>
</li>
<li><strong>加密算法攻击应用：</strong> 论文展示了如何利用上述方法对AES加密算法进行已知明文攻击（Known-Plaintext Attack）。具体地，通过访问加密文件并测量缓存的状态，攻击者能够在800次文件访问、65ms的测量时间和3秒钟的分析时间内提取出AES密钥。</li>
<li><strong>无需已知明文/密文的攻击：</strong> 论文还展示了一种不需要已知明文或密文的攻击方式，通过攻击者仅通过访问自身的内存空间即可提取到另一个进程的密钥位。这是一种非常强大的攻击形式，因为它不需要两个进程之间有任何显式通信。</li>
<li><strong>反制措施的挑战：</strong> 论文讨论了如何使AES的实现对这类缓存侧信道攻击免疫，并分析了几种可能的反制措施，但发现这些反制措施并不简单，且通常需要在性能和安全性之间做出平衡。</li>
</ul>
<h3 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h3><p>论文还回顾了缓存泄漏问题在不同研究中的背景，包括早期的理论探讨和实践研究：</p>
<ul>
<li><strong>早期研究：</strong> Hu（1992）最早提到通过缓存状态泄露进行跨进程通信的可能性；Kelsey等（1998）提出了基于缓存命中率的攻击方法；Page（2002）和Tsunoo等（2003）也探讨了基于缓存缺失的攻击方法。</li>
<li><strong>独立但并行的研究：</strong> 与本论文相关的工作包括Bernstein（2001）的AES缓存攻击，虽然方法上与论文中的<code>Evict+Time</code>方法类似，但它不依赖于显式的缓存模型，也没有像本文那样主动操作缓存。Bernstein的方法更简单、跨平台，但也有其局限性，如需要已知密钥的参考测量，并且在很多系统上由于信噪比低，效果不佳。</li>
<li><strong>其他缓存攻击研究：</strong> Percival（2003）也提出了针对RSA的缓存攻击，虽然攻击方法相似，但与AES的加密过程和时间尺度有所不同，因此具体实现和适用的攻击场景不同。</li>
<li><strong>已有反制措施：</strong> 论文还讨论了针对这些缓存侧信道攻击的已有反制措施，包括理论性和实践性的缓解方法，但这些方法通常需要在性能和安全性之间做出折衷。</li>
</ul>
<h2 id="Preliminaries-1"><a href="#Preliminaries-1" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><ul>
<li><p>回顾内存和缓存结构</p>
<p><strong>缓存结构：</strong> 现代处理器通常使用多级的集合关联（set-associative）缓存。每个缓存集（cache set）包含若干缓存行（cache lines），每行存储一个内存块（memory block）。内存块的大小为 <code>B</code> 字节。当发生缓存缺失（cache miss）时，整个内存块会被复制到缓存的某个缓存行中。内存块的映射遵循特定规则：每个内存块只能存储在特定的缓存集内，缓存集的编号是根据内存地址计算出来的，具体为 <code>(地址 // B) % S</code>，其中 <code>S</code> 是缓存集的数量，<code>B</code> 是缓存行的大小。每个缓存集中的缓存行是竞争资源，多个内存块可能会争用同一个缓存集。</p>
</li>
<li><p>AES的内存访问</p>
<p><strong>AES加密算法：</strong> AES使用查找表（lookup tables）来加速加密过程，这些表格预先计算好，包含了特定数据的变换，特别是在每一轮的加密中。论文重点介绍了AES的内存访问模式，因为AES的查找表访问模式对于缓存攻击非常脆弱。</p>
<p><strong>加密过程：</strong> AES的加密过程涉及多个步骤，其中每一轮的加密都通过查找表进行数据变换。AES的关键扩展产生了多个轮密钥，并且每轮都涉及多个查找表（如T0、T1等）进行数据替换。第十轮与前九轮不同，最后一轮去除了混合列（MixColumns）操作，使用了不同的查找表（如 T(10)0、T(10)1 等）。</p>
<p><strong>攻击场景：</strong> 本文的攻击主要通过访问这些查找表来推测AES密钥。由于查找表在内存中是连续存储的，攻击者可以通过缓存侧信道观察到不同内存块的访问模式，从而获取关键信息。</p>
</li>
<li><p>符号</p>
<p>论文中使用了一些符号来表示AES加密过程中的内存块和访问模式。例如：</p>
<ul>
<li><code>δ</code> 表示缓存行大小除以每个表条目的大小。通常情况下，<code>δ = 16</code>。</li>
<li><code>hy_i</code> 表示给定字节 <code>y</code> 在查找表 <code>T</code> 中对应的内存块。</li>
<li><code>Qk(p,l, y)</code>是一个谓词，表示AES加密过程中是否访问了查找表<code>T</code> 中某个特定的内存块。<code>Qk(p,l , y) 会在给定的AES密钥 k和明文 p 下评估出是否访问了某个表条目</code>。</li>
</ul>
<p><strong>测量分布：</strong> 论文提到会根据某些测量方法从分布 <code>Mk(p, </code>, y)` 中采样数据，来衡量某个内存块是否被访问。这些测量的预期值在访问特定内存块时会有不同，从而可以用于推测加密密钥。</p>
</li>
</ul>
<h2 id="Synchronous-Known-Data-Attacks"><a href="#Synchronous-Known-Data-Attacks" class="headerlink" title="Synchronous Known-Data Attacks"></a>Synchronous Known-Data Attacks</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>同步已知数据攻击是指攻击者已知明文或密文，并能够与加密过程同步操作。攻击者可以通过某些接口（如VPN、加密存储服务等）触发加密操作，从而利用该接口进行攻击，试图揭示用于加密的数据的密钥。比如：</p>
<ul>
<li>在VPN中，未经授权的用户可能会向一个安全通道发送数据包，触发加密操作，而这些数据包的明文内容部分已知。通过同步攻击，攻击者有可能暴力破解VPN密钥。</li>
<li>在Linux的dm-crypt和cryptoloop服务中，用户可能在已知文件系统上触发加密操作，并使用该信息进行同步攻击，最终发现用于加密存储的密钥。</li>
</ul>
<p>这类攻击依赖于已知明文或密文，以及能够触发加密过程的能力。实验结果表明，攻击者通过大约65ms的测量时间（包括800次写入操作）即可成功提取AES密钥。</p>
<h3 id="单轮攻击（One-Round-Attack）"><a href="#单轮攻击（One-Round-Attack）" class="headerlink" title="单轮攻击（One-Round Attack）"></a>单轮攻击（One-Round Attack）</h3><p>单轮攻击是同步攻击中的一种基本方法，利用了AES加密的第一个回合中的特性。特别是，在AES的第一轮中，访问的查找表索引是通过 <code>x(0)i = pi ⊕ ki</code> 计算的，其中 <code>pi</code> 是明文字节，<code>ki</code> 是密钥字节。因此，攻击者只需要知道明文字节 <code>pi</code> 和对应的查找表索引 <code>x(0)i</code>，就能获得密钥字节 <code>ki</code> 的部分信息。</p>
<ul>
<li><p><strong>攻击步骤</strong>：</p>
<ol>
<li>假设攻击者能获取到某些理想化的谓词 <code>Qk(p, l, y)</code>，这个谓词表示AES加密过程是否访问了某个内存块。<code>p</code> 是已知的随机明文，<code>k</code> 是密钥，<code>y</code> 是查找表索引。</li>
<li>攻击者通过猜测密钥字节 <code>ki</code>，并计算出候选值 <code>˜ki</code> 来预测内存块的访问情况。如果 <code>˜ki</code> 和真实的 <code>ki</code> 相同，那么查找表将访问正确的内存块，<code>Qk(p, </code>, y)` 应该为1。</li>
<li>如果候选密钥 <code>˜ki</code> 错误，那么该内存块就不会被访问，攻击者就能确认该候选值是错误的。</li>
<li>通过这种方法，攻击者可以推测出每个密钥字节的高4位（假设 <code>δ = 16</code>），即密钥的前半部分。</li>
</ol>
</li>
<li><p><strong>噪声处理</strong>：由于实际中无法获得理想的谓词 <code>Qk(p, l, y)</code>，攻击者需要处理噪声。实际的测量分布 <code>Mk(p, l, y)</code> 与理想谓词 <code>Qk(p, l, y)</code> 存在相关性，但同时会带来噪声。因此，攻击者通常通过对多个样本进行平均化处理，来减少噪声的影响。</p>
</li>
<li><p><strong>测量得分</strong>：攻击者计算每个候选密钥 <code>˜ki</code> 的候选得分，该得分是通过测量样本的平均值得到的。得分较高的候选密钥值与真实密钥 <code>ki</code> 更为接近，从而帮助攻击者确定密钥。</p>
</li>
<li><p><strong>实验结果</strong>：在一些实验中（如Linux 2.6.11上的dm-crypt文件系统），该攻击成功提取了每个密钥字节的高半部分。图2展示了一个实验中的候选得分，其中高位的密钥字节（如 <code>k5</code>）可以通过得分明显区分出来。</p>
</li>
<li><h4 id="图2-实验结果"><a href="#图2-实验结果" class="headerlink" title="图2. 实验结果"></a>图2. 实验结果</h4><p>图2展示了一个同步攻击使用Prime+Probe技术进行的实验。攻击分析了一个dm-crypt加密的文件系统，分别在测量了30,000次和800次触发加密操作后，计算出每个密钥字节的候选得分。横轴表示密钥候选值，纵轴表示测量得分。通过这种方法，攻击者能够显著识别出每个密钥字节的前四位（例如 <code>k5 = 0x50</code>）。</p>
</li>
</ul>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241114155844132.png" alt="image-20241114155844132"></p>
<h2 id="PoC执行"><a href="#PoC执行" class="headerlink" title="PoC执行"></a>PoC执行</h2><p>配置设备特定的硬件参数，确保在 <code>./src/device_conf.h</code> 中输入正确的缓存维度和其他常量信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> CacheSC</span><br><span class="line">make</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r install/pip_requirements.txt</span><br></pre></td></tr></table></figure>

<p>单次逐出测试</p>
<p>测量单个缓存行访问的场景：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./demo</span><br><span class="line">make single-eviction</span><br><span class="line">./demo/single-eviction 10000 &gt; /tmp/attack.log</span><br><span class="line">./scripts/plot-log.py -o /tmp -v -t /tmp/attack.log</span><br></pre></td></tr></table></figure>

<p>选择明文攻击 OpenSSL AES-CBC</p>
<p>该攻击采用了经典的选择明文攻击，针对OpenSSL AES-CBC加密中的密钥字节恢复。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./demo</span><br><span class="line">OPENSSL_INCL=/path/to/openssl/include OPENSSL_LIB=/path/to/openssl/lib make openssl-aes-cbc</span><br><span class="line">./scripts/plot-log.py -o /tmp/cachesc -v -t -n /tmp/attack.log</span><br></pre></td></tr></table></figure>

<p>Argon2d 测试</p>
<p>提供对Argon2d算法的缓存访问模式观察。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ARGON_INCL=/path/to/argon2/include ARGON_LIB=/path/to/argon2/lib make argon2d-attacker argon2d-victim</span><br><span class="line">sudo ./argon2d-attacker &gt; /tmp/attacker.log &amp;</span><br><span class="line">sleep 1</span><br><span class="line">./argon2d-victim 10 &gt; /tmp/victim.log</span><br><span class="line">sudo pkill -SIGINT -f argon2d-attacker</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绘图脚本选项</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/plot-log.py -h</span><br></pre></td></tr></table></figure>

<p><code>CacheSC</code> 提供了灵活的缓存侧信道攻击接口，可用于研究不同场景下的缓存攻击细节。</p>
<p><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/image-20241114162223870.png" alt="image-20241114162223870"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">mobb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/">http://example.com/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">All about secret</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/14/Intel-64-IA-32-Program-Note/"><img class="prev-cover" src="/2024/11/14/Intel-64-IA-32-Program-Note/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Intel-64-IA-32-Program-Note</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机系统结构学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mobb</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spectre-Attacks"><span class="toc-number">1.</span> <span class="toc-text">Spectre Attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-number">1.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E7%9A%84%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">了解的背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ROP%EF%BC%88Reorder-Buffer%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">ROP（Reorder Buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDB%EF%BC%88Common-Data-Bus%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">CDB（Common Data Bus）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CDB-%E5%92%8C-ROB-%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">CDB 和 ROB 的协同工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E3%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E3%80%81%E6%8A%95%E6%9C%BA%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">乱序执行、分支预测、投机执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">缓存架构与地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AES%E5%8A%A0%E5%AF%86%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%94%BB%E5%87%BB"><span class="toc-number">1.3.5.</span> <span class="toc-text">AES加密与传统攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T%E8%A1%A8"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">T表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%BC%93%E5%AD%98%E6%94%BB%E5%87%BB%EF%BC%88%E4%BB%A5Prime-Probe%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">传统的缓存攻击（以Prime+Probe为例）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Prime-Scope-Attack"><span class="toc-number">2.</span> <span class="toc-text">Prime+Scope Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract-1"><span class="toc-number">2.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-1"><span class="toc-number">2.2.</span> <span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%8C%91%E6%88%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">两个挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prime-Scope%E7%9A%84%E7%AA%81%E7%A0%B4"><span class="toc-number">2.2.2.</span> <span class="toc-text">Prime+Scope的突破</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preliminaries"><span class="toc-number">2.3.</span> <span class="toc-text">Preliminaries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache"><span class="toc-number">2.3.1.</span> <span class="toc-text">Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Side-Channel-Attacks"><span class="toc-number">2.3.2.</span> <span class="toc-text">Cache Side-Channel Attacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Manipulation-Paradigms"><span class="toc-number">2.3.3.</span> <span class="toc-text">Cache Manipulation Paradigms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windowless-Paradigm"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Windowless Paradigm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prime-Scope"><span class="toc-number">2.4.</span> <span class="toc-text">Prime+Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Threat-Model"><span class="toc-number">2.4.1.</span> <span class="toc-text">Threat Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#General-Description"><span class="toc-number">2.4.2.</span> <span class="toc-text">General Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instantition"><span class="toc-number">2.4.3.</span> <span class="toc-text">Instantition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-Efficient-Prime-Pattern"><span class="toc-number">2.5.</span> <span class="toc-text">Finding Efficient Prime Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrimeTime"><span class="toc-number">2.5.1.</span> <span class="toc-text">PrimeTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrimeTime-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.5.2.</span> <span class="toc-text">PrimeTime 的工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-Level-Cache-LLC"><span class="toc-number">2.5.3.</span> <span class="toc-text">Last-Level Cache(LLC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#primetime"><span class="toc-number">2.5.4.</span> <span class="toc-text">primetime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Covert-Channel"><span class="toc-number">2.5.5.</span> <span class="toc-text">Covert_Channel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Prime-Probe"><span class="toc-number">3.</span> <span class="toc-text">Prime+Probe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract-2"><span class="toc-number">3.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-2"><span class="toc-number">3.2.</span> <span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-number">3.2.1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Related-Works"><span class="toc-number">3.2.2.</span> <span class="toc-text">Related Works</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preliminaries-1"><span class="toc-number">3.3.</span> <span class="toc-text">Preliminaries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronous-Known-Data-Attacks"><span class="toc-number">3.4.</span> <span class="toc-text">Synchronous Known-Data Attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E6%94%BB%E5%87%BB%EF%BC%88One-Round-Attack%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">单轮攻击（One-Round Attack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE2-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">图2. 实验结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PoC%E6%89%A7%E8%A1%8C"><span class="toc-number">3.5.</span> <span class="toc-text">PoC执行</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/19/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="爬虫学习记录"><img src="/2024/11/19/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="爬虫学习记录"/></a><div class="content"><a class="title" href="/2024/11/19/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="爬虫学习记录">爬虫学习记录</a><time datetime="2024-11-19T15:46:07.000Z" title="发表于 2024-11-19 23:46:07">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/14/Intel-64-IA-32-Program-Note/" title="Intel-64-IA-32-Program-Note"><img src="/2024/11/14/Intel-64-IA-32-Program-Note/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intel-64-IA-32-Program-Note"/></a><div class="content"><a class="title" href="/2024/11/14/Intel-64-IA-32-Program-Note/" title="Intel-64-IA-32-Program-Note">Intel-64-IA-32-Program-Note</a><time datetime="2024-11-14T02:22:25.000Z" title="发表于 2024-11-14 10:22:25">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/" title="微架构安全论文学习集"><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微架构安全论文学习集"/></a><div class="content"><a class="title" href="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/" title="微架构安全论文学习集">微架构安全论文学习集</a><time datetime="2024-10-09T02:47:23.000Z" title="发表于 2024-10-09 10:47:23">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机系统结构学习笔记"><img src="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机系统结构学习笔记"/></a><div class="content"><a class="title" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机系统结构学习笔记">计算机系统结构学习笔记</a><time datetime="2024-09-16T08:52:10.000Z" title="发表于 2024-09-16 16:52:10">2024-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/" title="文献查找攻略"><img src="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献查找攻略"/></a><div class="content"><a class="title" href="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/" title="文献查找攻略">文献查找攻略</a><time datetime="2024-07-03T12:05:27.000Z" title="发表于 2024-07-03 20:05:27">2024-07-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By mobb</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>