<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CTF逆向实战ichunqiu | All about secret</title><meta name="author" content="mobb"><meta name="copyright" content="mobb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="入门篇前三在CTF逆向题目或实际软件破解中，常常会碰到.NET家族语言开发的程序，如C#。针对这类程序，使用IDA Pro打开时会额外提供一个选项，即 Microsoft .NET asssembly（微软.NET汇编语言），IDA Pro会将程序翻译为微软中间语言，使用reflector分析。 微软中间语言（MSIL, Microsoft Intermediate Language）:也被称作M">
<meta property="og:type" content="article">
<meta property="og:title" content="CTF逆向实战ichunqiu">
<meta property="og:url" content="http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/index.html">
<meta property="og:site_name" content="All about secret">
<meta property="og:description" content="入门篇前三在CTF逆向题目或实际软件破解中，常常会碰到.NET家族语言开发的程序，如C#。针对这类程序，使用IDA Pro打开时会额外提供一个选项，即 Microsoft .NET asssembly（微软.NET汇编语言），IDA Pro会将程序翻译为微软中间语言，使用reflector分析。 微软中间语言（MSIL, Microsoft Intermediate Language）:也被称作M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/img1.png">
<meta property="article:published_time" content="2022-04-15T02:28:22.000Z">
<meta property="article:modified_time" content="2022-05-09T16:24:09.707Z">
<meta property="article:author" content="mobb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/img1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CTF逆向实战ichunqiu',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-10 00:24:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/img1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">All about secret</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CTF逆向实战ichunqiu</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-15T02:28:22.000Z" title="发表于 2022-04-15 10:28:22">2022-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-09T16:24:09.707Z" title="更新于 2022-05-10 00:24:09">2022-05-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CTF逆向实战ichunqiu"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="入门篇前三"><a href="#入门篇前三" class="headerlink" title="入门篇前三"></a>入门篇前三</h1><p>在CTF逆向题目或实际软件破解中，常常会碰到.NET家族语言开发的程序，如C#。针对这类程序，使用IDA Pro打开时会额外提供一个选项，即 <code>Microsoft .NET asssembly</code>（微软.NET汇编语言），IDA Pro会将程序翻译为微软中间语言，<code>使用reflector</code>分析。</p>
<p><strong>微软中间语言（MSIL, Microsoft Intermediate Language）</strong>:也被称作MSIL汇编。虽然微软.NET框架很智能，其实它只认IL。无论程序采用什么高级语言编写，都将被编译器编译为IL并保存在PE文件中。虽被称作汇编，但相比win32汇编语言，IL可谓是名副其实的高级语言：它支持面向对象，通常不直接操作内存地址，以堆栈机的方式运行。由于运行完全受.NET监控，因此IL属于托管（Managed）代码，与之对应的是本机代码，被称为非托管代码。</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220416112641533.png" alt="image-20220416112641533"></p>
<p>GUID:</p>
<p>全局唯一标识符（GUID，Globally Unique Identifier）是一种由算法生成的二进制长度为128位的数字标识符。GUID主要用于在拥有多个节点、多台计算机的网络或系统中。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。GUID 的总数达到了2^128（3.4×10^38）个，所以随机生成两个相同GUID的可能性非常小，但并不为0。所以，用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证这种重复的情况不会发生。</p>
<p>GUID一词有时也专指微软对UUID标准的实现。</p>
<p>在 Windows 平台上，GUID 广泛应用于微软的产品中，用于标识如注册表项、类及接口标识、数据库、系统目录等对象。</p>
<p>字符移位：</p>
<p>例如：如果是小写字母<code>v9 = (v8 - 83) % 26 + 97</code>,等价于<code>v9 = (v8 - 97 + 14) % 26 + 97</code>，即向后移动14个字符；如果输入是大写字母，则：<code>v9 = (v8 - 51) % 26 + 97</code>,等价于<code>v9 = (v8 - 65 + 14) % 26 + 97</code>，也是向后移动14个字符；如果输入是其他字符，则不做任何操作。最后把经过移位后的字符串与check字符串即”Z3h_i5_psu1b_h0_F3jsfg3”相比较，相等就输出正确flag，最后逆向过来就是移位12</p>
<p><code>v9=&#123; v9 - 97 + 12 &#125; % 26 + 97</code>    <code>v9=&#123; v9 - 65+ 12 &#125; % 26 + 65</code></p>
<h1 id="入门篇四"><a href="#入门篇四" class="headerlink" title="入门篇四"></a>入门篇四</h1><p>在CTF逆向实战题目中，如果主办方是python的忠实爱好者，那么可能会出现使用python语言编写，使用py2exe或pyinstaller进行打包成exe，针对这种程序一般需要采取特定方式进行处理。</p>
<p>可以通过py开头的字符串常量信息，确定是由python编写后打包的程序。</p>
<p>本步骤我们使用pyinstxtractor解包目标程序，并进行逆向分析获取flag字符串</p>
<p>CTF逆向分析中常使用pyinstxtractor.py脚本来提取pyinstall打包的exe文件的内容，脚本同时也可以提取出可执行文件中的pyz文件的内容。这里需要注意的一点是，如果源程序是使用python3进行编译打包的，需要使用python3执行该脚本，如果使用python2执行则会提取出错。依据提取后的内容，可以有选择地对pyc文件进行逆向，或者有时可以直接获取python代码。</p>
<p>在CTF逆向分析中，如果程序在运行阶段时动态生成flag字符串，可以通过windbg加载目标程序进行搜索字符串，获取对应范围内的flag。</p>
<p>Windbg是在windows平台下，强大的用户态和内核态调试工具。相比较于Visual Studio，它是一个轻量级的调试工具，所谓轻量级指的是它的安装文件大小较小，但是其调试功能，却比VS更为强大。它的另外一个用途是可以用来分析dump数据。windbg更多用于进行软件漏洞分析，相较于Ollydbg其用户界面友好性较差，但是针对崩溃点可以输出详细的调试信息。</p>
<p>如果需要了解windbg的详细使用命令，可以在命令窗口输入?或者在线查询即可。</p>
<p>windbg命令行输入g命令，使得程序继续运行起来，在程序中输入任意字符，并按回车：</p>
<p>程序暂停后，在命令行窗口输入命令 <code>s -a 0x1 0x10000000 &quot;@flare-on.com&quot;</code></p>
<p>s表示搜索字符串，-a表示ASCII码形式，如果使用-u表示unicode形式。接下来的参数分别为起始地址、结束地址和搜索内容，最大搜索范围不能超过0x10000000。</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220417135147412.png" alt="image-20220417135147412"></p>
<p>按照步骤来了，但却没有打印正确的字符串</p>
<p>输入d 0182cc78往前一个地址后找到flag</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220417135426867.png" alt="image-20220417135426867"></p>
<h1 id="入门篇五"><a href="#入门篇五" class="headerlink" title="入门篇五"></a>入门篇五</h1><p>在CTF逆向题目或实际软件破解中，针对有界面的逆向程序往往有一些确定注册的按钮，点击按钮后跳转到check的代码逻辑。而这些代码，往往是逆向分析中的核心代码，也是动态调试时着重关注的代码逻辑段。因此，确定点击按钮后，按钮响应函数的位置就是带界面逆向分析中的关键所在。</p>
<p>我们这里首先使用xspy定位按钮响应函数位置。</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420165001694.png" alt="image-20220420165001694"></p>
<p>{</p>
<p>​     olleydbg中的各个窗口</p>
<p>​      L：打开日志窗口；<br>​      E：打开可执行模块窗口；<br>​      M：打开内存映射窗口；<br>​      W：打开窗口列表；指被反汇编的程序所包含的窗口；<br>​      T：打开线程窗口；查看被反汇编的程序所包含的线程；<br>​      C：打开CPU窗口；默认打开；<br>​      R：打开搜索结果窗口；<br>​      …：打开运行跟踪窗口；<br>​      K：打开调用堆栈窗口；</p>
<p>}</p>
<p>本步骤通过使用xspy工具查看按钮ID对应按钮响应函数地址关系，再通过OllyIce查看窗口信息，寻找标题与ID的对应关系，从而确定按钮响应函数的虚拟地址。</p>
<p>在CTF逆向分析过程中，如果碰到无法使用xpsy的程序，更稳妥的方式是寻找按钮响应函数中的一些windows函数调用，针对这些函数调用设置断点，同样可以中断在按钮响应函数中，甚至有时候离关键代码比方法1更近。针对像本题目中带界面的程序，常用的思路是中断在读取字符输入的位置，一般针对<code>GetDlgItemTextA/W</code>和<code>GetWindowTextA/W</code>进行下断。</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420170204673.png" alt="image-20220420170204673"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420170639482.png" alt="image-20220420170639482"></p>
<p>在CTF逆向分析中，往往对应的flag字符串是在程序运行过程中动态生成的，和第一节给你自信中不同，直接通过查看静态对应字符串内容是无法得到正确的flag的，这时候就需要进行内存追码。进行内存追码的前提是，已经成功定位了按钮响应函数，这样才可以让程序中断在关键逻辑代码处，进行追码和分析。</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420171424721.png" alt="image-20220420171424721"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420171456721.png" alt="image-20220420171456721"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420171801799.png" alt="image-20220420171801799"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420171851287.png" alt="image-20220420171851287"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420172205660.png" alt="image-20220420172205660"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420172216878.png" alt="image-20220420172216878"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220420172301813.png" alt="image-20220420172301813"></p>
<h1 id="入门篇六（1）"><a href="#入门篇六（1）" class="headerlink" title="入门篇六（1）"></a>入门篇六（1）</h1><ul>
<li><p>RVA：RVA 是相对虚拟地址（Relative Virtual Address）的缩写，它是文件映射到内存中的“相对地址”。</p>
</li>
<li><p>FOA：FOA是文件偏移地址（File Offest Address）的缩写，它是文件在磁盘上存放时相对文件开头的偏移地址。</p>
<p>VA，虚拟地址，也就是程序被加载到内存中的地址<br>RVA，以虚拟地址前边加上个“相对的”，也就是说它还是按虚拟地址来换算，只不过不是从0开始，而是把一个模块的基址作为参考点。<br>RAW ADRRESS，或者FILE OSSFET，一般称文件偏移，你把一个文件看成一个连续的字节流，OFFSET就是这个字节流中的位置。<br>//文件偏移又称物理偏移，就是保存在磁盘里的文件。</p>
<p>换算关系为：<br>将VA减去MODULE的BASE就是RVA的值。</p>
<p>RVA与OFFSET的关系，是通过每个SECTION内领衔量相等为换算的。举例来说，假设一个EXE文件，BASE为0x00400000，第一个SECTION的名字叫.text，它的RVA是0x2000，那么它的VA就是0x00402000，也就是它个SECTION在内存中的起始地址是0x00402000；若假设这个SECTION的OFFSET是0x1000，那么最终的结果是，文件中从0x1000开始的一个SECTION，被映射到了内存地址0x00402000开始的内存区间。假设有一段代码位于这个SECTION中，它的地址（VA）是0x00402345，相当于它的RVA是0x2345，而它在SECTION内部的偏移量是0x0345，所以它的文件中的偏移量就是0x1000（SECTION的起始偏移量） + 0x0345，即0x1345。</p>
<p>总结：VA与RVA只相差一个BASE值，而VA与OFFSET的换算，关键是要确定这个地址属于哪一个SECTION。</p>
<p>什么是偏移量？</p>
<p>汇编语言中的定义为：<br>把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为“有效地址或偏移量”。 亦： 存储单元的实际地址与其所在段的段地址之间的距离。本质其实就是“实际地址与其所在段的段地址之间的距离”<br>更通俗一点讲，内存中存储数据的方式是：一个存储数据的“实际地址”=段首地址+偏移量，<br>你也可以这样理解：就像我们现实中的“家庭地址”=“小区地址”+“门牌号”<br>上面的“偏移量”就好比“门牌号”</p>
<p>其实就相当于C++的指针一样啦，指出确切的地址而已……</p>
</li>
</ul>
<p>查找来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/god00/article/details/6217367">(63条消息) RVA、VA、RAW、偏移量_god00的博客-CSDN博客</a></p>
<h2 id="步骤1：确定Dll导出函数信息"><a href="#步骤1：确定Dll导出函数信息" class="headerlink" title="步骤1：确定Dll导出函数信息"></a>步骤1：确定Dll导出函数信息</h2><p>在CTF逆向题目或实际软件破解中，常常会碰到需要对某个关键Dll进行逆向分析，对于一些关键代码或者需要反复使用的函数或类接口，开发者通常使用Dll工程将代码打包成Dll，再将接口开放出来，供使用者调用，这样也一定程度上保护了核心代码。在进行Dll的逆向时，我们一般需要确定关键函数的导出信息，包括：函数所在Dll中的偏移、函数名称、完整函数头等，便于我们后续进行分析。</p>
<p>我们这里分别使用IDA Pro和dumpbin载入分析Dll程序，尝试确定函数导出信息。</p>
<p>（1）首先我们从 <code>开始</code> 点击运行，输入cmd打开命令行窗口，或者直接点击命令提示符，然后在命令行窗口输入 <code>dumpbin /?</code> 显示dumpbin的帮助信息</p>
<p>（2）接下来我们移动到DllReverser.dll的文件夹，输入命令 <code>cd C:\Documents and Settings\Administrator\Desktop\1_06_DllReverser</code>，这个文件夹看自己的dll文件在哪</p>
<p>这样是为了便于后续的命令行操作，平常也要养成在平行目录操作的好习惯。</p>
<p>（3）接下来我们查看DllReverser.dll的导出函数信息，输入 <code>dumpbin /EXPORTS DllReverser.dll</code></p>
<p>通过输出结果我们可以看出，dll包括一个导出函数check_flag，通过名字可以判断出是用来检测flag字符串的函数，其相对虚拟地址偏移（RVA）为0x1010。</p>
<p>（4）然后，我们使用IDA Pro载入Dll进行分析，可以看到同样可以识别出是x86程序</p>
<p>（5）这里可以看到Dll文件加载的虚拟基址为0x10000000，加上之前得到的偏移为0x10001010，使用快捷键 <code>G</code> 输入0x10001010或者直接点击函数窗体check_flag函数，都可以定位到导出点函数</p>
<p>（6）使用快捷键 <code>F5</code> 可以进行反编译，获得函数伪C代码</p>
<p>（7）这里根据猜测，a1应该是传入的flag字符串，类型为char*，我们使用 右键 -&gt; Rename lvar/ Set lvar type来修改a1的名称和类型</p>
<p>（8）再通过 右键 -&gt; Hexadecimal 将后面的判断部分改为十六进制</p>
<p>通过修改后的代码，大概可以看到check函数的代码逻辑，接下来我们考虑动态调试，进一步梳理代码逻辑。同时，我们得到了函数声明如下： <code>signed int __cdecl check_flag(char *flag)</code>。</p>
<p>本步骤我们通过使用dumpbin命令和IDA Pro查看了函数导出表函数，并通过反编译功能简单梳理了代码静态逻辑，为动态调试做准备。</p>
<h2 id="步骤2：Ollydbg的LoadDll动态调试Dll文件"><a href="#步骤2：Ollydbg的LoadDll动态调试Dll文件" class="headerlink" title="步骤2：Ollydbg的LoadDll动态调试Dll文件"></a>步骤2：Ollydbg的LoadDll动态调试Dll文件</h2><blockquote>
<p>本步骤使用Ollydbg的LoadDll插件加载目标Dll，对关键函数进行动态调试</p>
</blockquote>
<p>具有LoadDll插件支持的Ollydbg，在载入Dll程序时，会弹框提醒是否调用LoadDll.exe，进行载入。正常情况下，载入后会自动暂停到Dll文件入口处位置。但是由于无法针对特定函数传入参数进行调用，因此也相对麻烦。</p>
<p>在CTF逆向实战中，针对Dll逆向程序，尤其是脱壳处理，会优先使用LoadDll模块，这样可以快速进行分析调试和文件转存。</p>
<p>（1）首先打开桌面上OllyIce文件夹下的OllyIce.exe，将DllReverser.dll拖入到OD窗体中，可以观察到OD直接提示是Dll文件，询问是否使用LoadDll.exe：</p>
<p>（2）点击是，可以发现OD反汇编显示在10001000处，但是实际EIP为00410148</p>
<p>（3）使用 <code>ALT + M</code> 快捷键，或者点击OD菜单栏中M按钮，<code>查看程序内存映射情况</code></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220423104950175.png" alt="image-20220423104950175"></p>
<p>这里可以看到LoadDll.exe的加载基址为00400000，DllReverser.dll的加载基址为10000000，因此关键函数的虚拟基址仍然为10001010。针对动态调用可以采用两种方式，一种直接修改EIP到10001010，但是这样堆栈中是没有参数数据的，我们采取另外一种方式，通过push + call的方式进行调用。</p>
<p>（4）接下来，我们将反汇编窗口向下拉，可以发现在最后有一段空白区域，或者直接按CTRL+G后输入10006FEF跳转到相应地址</p>
<p>（5）通过IDA Pro静态伪代码分析可知，flag长度为16个字节，’\0’结尾，然后每个字符都需要满足isalpha函数。isalpha函数是系统库函数，判断一个字符是否为字母（a-z、A-Z)是则返回true。我们接下来在空白区域填充16个字母，并以’\0’结尾。右键依次选择 二进制 -&gt; 编辑，或者使用 <code>CTRL + E</code> 快捷键</p>
<p>（6）在弹出框中ASCII码部分，填充“ABCDEFGHabcdefgh”，注意不要勾选保持大小，点击确定</p>
<p>（7）可以观察到对应虚拟地址空间，10006FEF开始地址的字节码已经被成功修改</p>
<p>（8）使用 <code>CTRL + G</code> 快捷键，输入10001000，跳转到反汇编窗口的起始位置</p>
<p>（9）单击选中10001000对应行，右键选择汇编或者使用快捷键空格，对该处地址的汇编代码进行修改</p>
<p>（10）依次修改为 <code>push 0x10006fef</code> 和 <code>call 0x10001010</code> 两句汇编语句</p>
<p>（11）一切就绪，我们设置EIP到10001000处。右键选择此处为新EIP，将EIP设置到我们修改的汇编代码处</p>
<p>在CTF逆向分析中，往往仅仅需要对关键代码逻辑进行分析，但是有时候触发跳转到关键代码逻辑的判断比较难以完成，可以在确定之前步骤不影响程序结果的基础上，直接修改EIP或者使用jump语句进行跳转，将控制流修改到关键函数入口处，从而进行直接的调试。采取此种方式时，要注意函数上下文条件是否满足，尤其是堆栈参数和堆栈平衡等。</p>
<p>（12）设置完毕可以观察寄存器窗口，发现EIP已经修改为10001000，我们使用快捷键 <code>F8</code> 进行单步。然后在到达 <code>call check_flag</code> 语句时，使用快捷键 <code>F7</code> 进行步入操作</p>
<p>（13）在进入check_flag函数领空后，观察右下角的堆栈信息可以发现，最上面为返回的EIP地址，下面为push指令压栈的函数参数</p>
<p>本步骤通过使用OD的LoadDll插件功能，加载了Dll文件，并通过修改填充虚拟地址数据，汇编修改代码，重定向EIP等方法，完成了关键函数的调用，至此Dll文件动态调试工作已经准备完毕，接下来我们对算法进行简单分析</p>
<h2 id="步骤3：check-flag函数算法分析"><a href="#步骤3：check-flag函数算法分析" class="headerlink" title="步骤3：check_flag函数算法分析"></a>步骤3：check_flag函数算法分析</h2><blockquote>
<p>本步骤对check_flag关键函数的算法进行简单分析，着重对比前两个小check逻辑</p>
</blockquote>
<p>在完成前两个步骤的基础上，本步骤我们继续针对check_flag函数进行调试，并对check算法进行简单分析。</p>
<p>（1）在函数入口10001010处，我们继续使用快捷键 <code>F8</code> 进行单步，直到1000101D处的 <code>repne scas byte ptr es:[edi]</code> 语句，我们可以看到我们修改填充的字符串，被放置到EDI寄存器中。</p>
<h3 id="REPNE-SCAS-BYTE-PTR-ES-EDI-指令详解"><a href="#REPNE-SCAS-BYTE-PTR-ES-EDI-指令详解" class="headerlink" title="REPNE SCAS BYTE PTR ES:[EDI] 指令详解"></a>REPNE SCAS BYTE PTR ES:[EDI] 指令详解</h3><p>[(63条消息) REPNE SCAS BYTE PTR ES:<a target="_blank" rel="noopener" href="https://blog.csdn.net/huiguixian/article/details/5689879">EDI] 指令详解_小小攻城师的博客-CSDN博客</a></p>
<p>（2）通过累加edi寄存器，直到edi指向内存指针为0，加上接下来的 <code>not ecx</code> 和 <code>dec ecx</code>相当于是执行了strlen(flag)代码，最终字符串长度放置在ecx寄存器中，<code>感觉这个应该就是求字符串长度，原理现在还不是很明白</code></p>
<p>这里执行完毕后，ecx寄存器的值为0x10 = 16，对应我们填充的字符串长度。</p>
<p>（4）接下来是一处比较，对应IDA Pro中 <code>strlen(flag) == 16</code>。满足这个校验后，接下来进入一段循环代码：</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220423140459049.png" alt="image-20220423140459049"></p>
<p>参考IDA Pro静态分析结果进行分析，可以得出本部分汇编指令首先将edi置0，然后在循环中累加，作为esi的偏移，esi指向目标字符串。通过调用函数10001111的返回值（isalpha，返回值放置到eax寄存器中），判断是否满足要求。</p>
<p>（5）我们单击10001052处代码，右键选择 断点 -&gt; 运行到选定位置，或者使用快捷键 <code>F4</code> ，直接跳过循环逻辑</p>
<p>（6）我们来到最后一处校验逻辑</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220423143706954.png" alt="image-20220423143706954"></p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220423143713177.png" alt="image-20220423143713177"></p>
<p>从汇编代码动态调试的实际数值可以看出，eax、ecx、edx、edi分别放置对应16字节字符，每四字节一组，然后再通过类似 <code>lea ebx, dword ptr [ecx+eax]</code> 和使用sub指令的方式，进行分别求和或求差，与对应写死的数值进行比较，最终四次比较全部通过，为正确的flag字符串。</p>
<h1 id="入门篇六（2）"><a href="#入门篇六（2）" class="headerlink" title="入门篇六（2）"></a>入门篇六（2）</h1><p>通过入门篇六（1）中的分析，可以得到其中重要的函数check_flag，新建一个dll工程，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ＜stdio.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ＜string.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ＜windows.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DllReverser.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HANDLE hModule, </span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call, </span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//当dll被某进程加载时</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> DLL_THREAD_DETACH:<span class="comment">//当dll被某线程卸载时</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">check_flag</span><span class="params">(<span class="keyword">char</span> *flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//EasyForDllReFlag</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strlen</span>(flag) != <span class="number">16</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Wrong flag length!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">15</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(flag[i]))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Wrong flag format!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> part1 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)&amp;flag[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> part2 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)&amp;flag[<span class="number">4</span>];</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> part3 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)&amp;flag[<span class="number">8</span>];</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> part4 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)&amp;flag[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (part1+part2==<span class="number">0xbde5d08b</span> &amp;&amp; part1-part2==<span class="number">0x3500f1ff</span> &amp;&amp; part3+part4==<span class="number">0xccb3d8b2</span> &amp;&amp; part4-part3==<span class="number">0x020effda</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Right flag! Your flag is TSCTF&#123;%s&#125;\n&quot;</span>, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Wrong!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本段C++代码是Dll工程的主文件，第一个函数DllMain为Dll的入口函数，可以在该函数中填充Dll被加载和卸载时执行的代码。第二个函数为flag字符串的校验函数check_flag，具体算法已经在上小节实验中进行分析，大家可以对比下动态调试结果和实际代码的差异。在逆向分析结束时，对比源码可以帮助修正逆向过程中对算法判断的偏差。</p>
<p>别忘了还有头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> BOOL _declspec(dllexport) <span class="built_in">check_flag</span>(<span class="keyword">char</span> *flag);</span><br></pre></td></tr></table></figure>

<p>第一句话是防止重复包含该头文件，第二句是声明一个dll导出函数。这里要注意，在cpp文件中必须要包含该头文件，否则不会生成check_flag函数相关汇编代码。</p>
<p>在上小节中，我们通过了两种方法获取了导出函数信息和函数声明。从开发者的角度考虑，如果需要动态调试Dll和验证flag字符串，除了上小节中的方法一外，还可以使用正向逻辑，即编写一个新程序调用该dll，然后针对这个新程序进行动态调试。   <code>其实就是建立一个可执行文件调用刚才写的dll，再对这个可执行文件进行逆向分析</code></p>
<p>然后再次新建，向工程中添加C++ Source file 文件 <code>main.cpp</code> ，并输入如下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ＜windows.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="title">int</span> <span class="params">(*Func_ptr)</span><span class="params">(<span class="keyword">char</span> *flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态加载DLL文件</span></span><br><span class="line">    hModule = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;DLLReverser.dll&quot;</span>);</span><br><span class="line"> Func_ptr check_flag = (Func_ptr)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;check_flag&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">check_flag</span>(<span class="string">&quot;ABCDEFGHabcdefgh&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到已经输出Wrong，接下来我们拷贝生成的exe和之前的dll到同一目录，就可以对dll的check_flag函数进行动态调试。</p>
<p>本步骤通过函数指针的方式，编写生成了调用Dll中check_flag关键函数的程序，用于下一步进行动态调试。</p>
<p>使用这种方法可以避免繁琐的OD修改操作，将Dll间接转换成可执行程序调试，相当于自己封装了一个针对性的LoadDll.exe，在已知关键函数和函数声明的前提下，具有较好的效果。</p>
<p>（1）拷贝出DllReverserApp.exe和DllReverser.Dll到同一目录下：</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220508140138798.png" alt="image-20220508140138798"></p>
<p>程序自动在入口点处中断一次，我们接下来需要在check_flag函数位置设置断点，可以采取包括查看常量字符串引用、查看内存镜像窗口、设置API断点等方法。</p>
<p>（3）我们采取最常用的字符串方式，右键选择 Ultra String Reference -&gt; Find Ascii：</p>
<p>（4）找到三个关键字符串，双击引用字符串，可以到我们编写的核心代码位置：</p>
<p><img src="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/image-20220508141026668.png" alt="image-20220508141026668"></p>
<p>（5）使用快捷键 <code>F2</code> 在00401088处设置断点，然后使用 <code>F9</code> 运行到断点位置，然后使用 <code>F7</code> 跟进函数</p>
<p>至此，已经成功跳转到check_flag函数领空，和方法二取得同样效果。</p>
<p>本步骤演示了通过调试调用Dll函数的程序效果，并通过定位到核心代码，可以继续进行动态调试，这个在上节实验里方法一处已经进行了演示，过程与之前相同。</p>
<p>解决这类问题要注意的是，由于是在寄存器中进行操作，相当于是DWORD无符号整型，因此需要考虑溢出的问题，如果有溢出需要加上0x100000000。</p>
<p>在本题示例中，由于之前对字符范围进行了限制，因此根据相减和加和结果判断，这里没有产生溢出。这里的方程组比较简单，相等于是求解两个二元一次方程组。如果针对更复杂多元高次方程组，可以使用matlab或者Mathematic进行方程组求解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">mobb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/">http://example.com/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">All about secret</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/img1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/10/%E6%B5%85%E5%AD%A6%E6%B1%87%E7%BC%96/"><img class="prev-cover" src="/2022/05/10/%E6%B5%85%E5%AD%A6%E6%B1%87%E7%BC%96/img1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浅学汇编</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/10/%E5%BC%95%E7%94%A8-new/"><img class="next-cover" src="/2022/02/10/%E5%BC%95%E7%94%A8-new/img1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">引用&amp;new</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mobb</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87%E5%89%8D%E4%B8%89"><span class="toc-number">1.</span> <span class="toc-text">入门篇前三</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87%E5%9B%9B"><span class="toc-number">2.</span> <span class="toc-text">入门篇四</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87%E4%BA%94"><span class="toc-number">3.</span> <span class="toc-text">入门篇五</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87%E5%85%AD%EF%BC%881%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">入门篇六（1）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E7%A1%AE%E5%AE%9ADll%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">4.1.</span> <span class="toc-text">步骤1：确定Dll导出函数信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9AOllydbg%E7%9A%84LoadDll%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Dll%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">步骤2：Ollydbg的LoadDll动态调试Dll文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9Acheck-flag%E5%87%BD%E6%95%B0%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">步骤3：check_flag函数算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#REPNE-SCAS-BYTE-PTR-ES-EDI-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.3.1.</span> <span class="toc-text">REPNE SCAS BYTE PTR ES:[EDI] 指令详解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%AF%87%E5%85%AD%EF%BC%882%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">入门篇六（2）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/14/Intel-64-IA-32-Program-Note/" title="Intel-64-IA-32-Program-Note"><img src="/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intel-64-IA-32-Program-Note"/></a><div class="content"><a class="title" href="/2024/11/14/Intel-64-IA-32-Program-Note/" title="Intel-64-IA-32-Program-Note">Intel-64-IA-32-Program-Note</a><time datetime="2024-11-14T02:22:25.000Z" title="发表于 2024-11-14 10:22:25">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/" title="微架构安全论文学习集"><img src="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微架构安全论文学习集"/></a><div class="content"><a class="title" href="/2024/10/09/%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E9%9B%86/" title="微架构安全论文学习集">微架构安全论文学习集</a><time datetime="2024-10-09T02:47:23.000Z" title="发表于 2024-10-09 10:47:23">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机系统结构学习笔记"><img src="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机系统结构学习笔记"/></a><div class="content"><a class="title" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="计算机系统结构学习笔记">计算机系统结构学习笔记</a><time datetime="2024-09-16T08:52:10.000Z" title="发表于 2024-09-16 16:52:10">2024-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/" title="文献查找攻略"><img src="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献查找攻略"/></a><div class="content"><a class="title" href="/2024/07/03/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE%E6%94%BB%E7%95%A5/" title="文献查找攻略">文献查找攻略</a><time datetime="2024-07-03T12:05:27.000Z" title="发表于 2024-07-03 20:05:27">2024-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/26/TED-learning/" title="TED learning"><img src="/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TED learning"/></a><div class="content"><a class="title" href="/2024/04/26/TED-learning/" title="TED learning">TED learning</a><time datetime="2024-04-25T16:42:42.000Z" title="发表于 2024-04-26 00:42:42">2024-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/2022/04/15/CTF%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98ichunqiu/img1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By mobb</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>